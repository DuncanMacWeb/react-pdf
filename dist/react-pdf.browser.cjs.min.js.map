{"version":3,"file":"react-pdf.browser.cjs.min.js","sources":["../src/font/emoji.js","../src/font/hyphenation.js","../src/utils/propsEqual.js","../src/renderer.js","../src/constants.js","../src/stylesheet/transformStyles.js","../src/font/font.js","../src/font/standard.js","../src/utils/warning.js","../src/font/index.js","../src/node/isImage.js","../src/utils/png.js","../src/utils/jpeg.js","../src/utils/cache.js","../src/image/resolveImage.js","../src/image/getSource.js","../src/image/fetchImage.js","../src/text/emoji.js","../src/layout/resolveAssets.js","../src/stylesheet/flatten.js","../src/stylesheet/expandStyles.js","../src/stylesheet/transformUnits.js","../src/stylesheet/resolveMediaQueries.js","../src/layout/resolveStyles.js","../src/layout/resolveZIndex.js","../src/node/hasVerticalRuler.js","../src/node/hasHorizontalRuler.js","../src/layout/resolveRulers.js","../src/utils/matchPercent.js","../src/node/getOrigin.js","../src/layout/resolveOrigins.js","../src/page/getOrientation.js","../src/page/isLandscape.js","../src/page/getSize.js","../src/utils/assocIfNil.js","../src/layout/resolvePageSizes.js","../src/utils/firstPass.js","../src/node/getMargin.js","../src/node/getPadding.js","../src/node/getPosition.js","../src/node/getDimension.js","../src/node/getBorderWidth.js","../src/utils/upperFirst.js","../src/node/setYogaValue.js","../src/node/setFlex.js","../src/node/setDisplay.js","../src/node/setOverflow.js","../src/node/setFlexWrap.js","../src/node/setFlexGrow.js","../src/node/setFlexBasis.js","../src/node/setAlign.js","../src/node/setAlignSelf.js","../src/node/setFlexShrink.js","../src/node/setAspectRatio.js","../src/node/setAlignContent.js","../src/node/setPositionType.js","../src/node/setFlexDirection.js","../src/node/setJustifyContent.js","../src/node/setMargin.js","../src/node/setPadding.js","../src/node/setBorderWidth.js","../src/node/setPosition.js","../src/node/setDimension.js","../src/node/isText.js","../src/node/isNote.js","../src/node/isPage.js","../src/node/isCanvas.js","../src/text/standardFont.js","../src/text/fontSubstitution.js","../src/utils/capitalize.js","../src/text/ignorableChars.js","../src/node/isTextInstance.js","../src/text/getAttributedString.js","../src/text/layoutText.js","../src/text/linesWidth.js","../src/text/linesHeight.js","../src/text/measureText.js","../src/image/getRatio.js","../src/page/isHeightAuto.js","../src/image/measureImage.js","../src/canvas/measureCanvas.js","../src/layout/resolveDimensions.js","../src/layout/resolveTextLayout.js","../src/layout/resolveInheritance.js","../src/node/removeMargins.js","../src/layout/resolvePageMargins.js","../src/node/getNodesHeight.js","../src/node/shouldBreak.js","../src/page/getContentArea.js","../src/layout/resolvePageBreaks.js","../src/node/split.js","../src/layout/resolvePageSplitting.js","../src/layout/resolvePageWrapping.js","../src/layout/resolveNoteChildren.js","../src/layout/resolvePagePaddings.js","../src/layout/resolvePercentRadius.js","../src/layout/resolvePercentHeight.js","../src/node/isLink.js","../src/layout/resolveLinkSubstitution.js","../src/layout/resolveAbsoluteCoordinates.js","../src/utils/asyncCompose.js","../src/layout/index.js","../src/pdf/save.js","../src/pdf/restore.js","../src/pdf/renderText.js","../src/pdf/renderPage.js","../src/utils/url.js","../src/link/getSource.js","../src/pdf/renderLink.js","../src/pdf/renderNote.js","../src/pdf/clipNode.js","../src/image/resolveObjectFit.js","../src/pdf/renderImage.js","../src/canvas/painter.js","../src/pdf/renderCanvas.js","../src/pdf/renderRulers.js","../src/pdf/addMetadata.js","../src/pdf/renderDebug.js","../src/pdf/renderBorders.js","../src/pdf/renderBackground.js","../src/pdf/applyTransformations.js","../src/pdf/render.js","../src/stylesheet/index.js","../src/index.js","../src/canvas.js","../src/dom.js"],"sourcesContent":["let emojiSource;\n\nexport const registerEmojiSource = ({ url, format = 'png' }) => {\n  emojiSource = { url, format };\n};\n\nexport const getEmojiSource = () => emojiSource;\n\nexport default {\n  registerEmojiSource,\n  getEmojiSource,\n};\n","let hyphenationCallback;\n\nexport const registerHyphenationCallback = callback => {\n  hyphenationCallback = callback;\n};\n\nexport const getHyphenationCallback = () => hyphenationCallback;\n\nexport default {\n  registerHyphenationCallback,\n  getHyphenationCallback,\n};\n","/**\n * Checks if two sets of props are equal (recursively)\n *\n * @param {Object} props A\n * @param {Object} props B\n * @returns {Boolean} props equals?\n *\n */\nconst propsEqual = (a, b) => {\n  const oldPropsKeys = Object.keys(a);\n  const newPropsKeys = Object.keys(b);\n\n  if (oldPropsKeys.length !== newPropsKeys.length) {\n    return false;\n  }\n\n  for (let i = 0; i < oldPropsKeys.length; i++) {\n    const propName = oldPropsKeys[i];\n\n    if (propName === 'render') {\n      if (!a[propName] !== !b[propName]) {\n        return false;\n      }\n      continue;\n    }\n\n    if (propName !== 'children' && a[propName] !== b[propName]) {\n      if (\n        typeof a[propName] === 'object' &&\n        typeof b[propName] === 'object' &&\n        propsEqual(a[propName], b[propName])\n      ) {\n        continue;\n      }\n\n      return false;\n    }\n\n    if (\n      propName === 'children' &&\n      (typeof a[propName] === 'string' || typeof b[propName] === 'string')\n    ) {\n      return a[propName] === b[propName];\n    }\n  }\n\n  return true;\n};\n\nexport default propsEqual;\n","'use strict';\n\nimport ReactFiberReconciler from 'react-reconciler';\n// import { createInstance } from './elements';\n\nimport propsEqual from './utils/propsEqual';\n\nconst emptyObject = {};\n\nconst createRenderer = onChange => {\n  return ReactFiberReconciler({\n    supportsMutation: true,\n\n    appendInitialChild(parentInstance, child) {\n      parentInstance.children.push(child);\n      onChange();\n    },\n\n    createInstance(type, { style, children, ...props }) {\n      return {\n        type,\n        box: {},\n        style: style || {},\n        props: props || {},\n        children: [],\n      };\n    },\n\n    createTextInstance(text, rootContainerInstance) {\n      return { type: 'TEXT_INSTANCE', value: text };\n    },\n\n    finalizeInitialChildren(element, type, props) {\n      return false;\n    },\n\n    getPublicInstance(instance) {\n      return instance;\n    },\n\n    prepareForCommit() {\n      // Noop\n    },\n\n    prepareUpdate(element, type, oldProps, newProps) {\n      return !propsEqual(oldProps, newProps);\n    },\n\n    resetAfterCommit(a, b, c) {\n      // Noop\n    },\n\n    resetTextContent(element) {\n      // Noop\n    },\n\n    getRootHostContext() {\n      return emptyObject;\n    },\n\n    getChildHostContext() {\n      return emptyObject;\n    },\n\n    shouldSetTextContent(type, props) {\n      return false;\n    },\n\n    now: Date.now,\n\n    useSyncScheduling: true,\n\n    appendChild(parentInstance, child) {\n      parentInstance.children.push(child);\n      onChange();\n    },\n\n    appendChildToContainer(parentInstance, child) {\n      parentInstance.children.push(child);\n      onChange();\n    },\n\n    insertBefore(parentInstance, child, beforeChild) {\n      const index = parentInstance.children.indexOf(beforeChild);\n      if (index !== -1 && child)\n        parentInstance.children.splice(index, 0, child);\n      onChange();\n    },\n\n    removeChild(parentInstance, child) {\n      const index = parentInstance.children.indexOf(child);\n      if (index !== -1) parentInstance.children.splice(index, 1);\n      onChange();\n    },\n\n    removeChildFromContainer(parentInstance, child) {\n      const index = parentInstance.children.indexOf(child);\n      if (index !== -1) parentInstance.children.splice(index, 1);\n      onChange();\n    },\n\n    commitTextUpdate(textInstance, oldText, newText) {\n      textInstance.value = newText;\n      onChange();\n    },\n\n    commitUpdate(instance, updatePayload, type, oldProps, newProps) {\n      const { style, ...props } = newProps;\n      instance.props = props;\n      instance.style = style;\n      onChange();\n    },\n  });\n};\n\nexport default createRenderer;\n","export const VIEW = 'VIEW';\nexport const TEXT = 'TEXT';\nexport const LINK = 'LINK';\nexport const PAGE = 'PAGE';\nexport const NOTE = 'NOTE';\nexport const IMAGE = 'IMAGE';\nexport const DOCUMENT = 'DOCUMENT';\nexport const CANVAS = 'CANVAS';\nexport const TEXT_INSTANCE = 'TEXT_INSTANCE';\n\nexport const DPI = 72; // 72pt per inch.\n\n// https://developer.mozilla.org/en-US/docs/Web/CSS/font-weight#Common_weight_name_mapping\nexport const FONT_WEIGHTS = {\n  thin: 100,\n  hairline: 100,\n  ultralight: 200,\n  extralight: 200,\n  light: 300,\n  normal: 400,\n  medium: 500,\n  semibold: 600,\n  demibold: 600,\n  bold: 700,\n  ultrabold: 800,\n  extrabold: 800,\n  heavy: 900,\n  black: 900,\n};\n\nexport const PAGE_SIZES = {\n  '4A0': [4767.87, 6740.79],\n  '2A0': [3370.39, 4767.87],\n  A0: [2383.94, 3370.39],\n  A1: [1683.78, 2383.94],\n  A2: [1190.55, 1683.78],\n  A3: [841.89, 1190.55],\n  A4: [595.28, 841.89],\n  A5: [419.53, 595.28],\n  A6: [297.64, 419.53],\n  A7: [209.76, 297.64],\n  A8: [147.4, 209.76],\n  A9: [104.88, 147.4],\n  A10: [73.7, 104.88],\n  B0: [2834.65, 4008.19],\n  B1: [2004.09, 2834.65],\n  B2: [1417.32, 2004.09],\n  B3: [1000.63, 1417.32],\n  B4: [708.66, 1000.63],\n  B5: [498.9, 708.66],\n  B6: [354.33, 498.9],\n  B7: [249.45, 354.33],\n  B8: [175.75, 249.45],\n  B9: [124.72, 175.75],\n  B10: [87.87, 124.72],\n  C0: [2599.37, 3676.54],\n  C1: [1836.85, 2599.37],\n  C2: [1298.27, 1836.85],\n  C3: [918.43, 1298.27],\n  C4: [649.13, 918.43],\n  C5: [459.21, 649.13],\n  C6: [323.15, 459.21],\n  C7: [229.61, 323.15],\n  C8: [161.57, 229.61],\n  C9: [113.39, 161.57],\n  C10: [79.37, 113.39],\n  RA0: [2437.8, 3458.27],\n  RA1: [1729.13, 2437.8],\n  RA2: [1218.9, 1729.13],\n  RA3: [864.57, 1218.9],\n  RA4: [609.45, 864.57],\n  SRA0: [2551.18, 3628.35],\n  SRA1: [1814.17, 2551.18],\n  SRA2: [1275.59, 1814.17],\n  SRA3: [907.09, 1275.59],\n  SRA4: [637.8, 907.09],\n  EXECUTIVE: [521.86, 756.0],\n  FOLIO: [612.0, 936.0],\n  LEGAL: [612.0, 1008.0],\n  LETTER: [612.0, 792.0],\n  TABLOID: [792.0, 1224.0],\n};\n\nexport const PORTRAIT = 'portrait';\nexport const LANDSCAPE = 'landscape';\n\nexport const INHERITED_PROPERTIES = [\n  'color',\n  'fontFamily',\n  'fontSize',\n  'fontStyle',\n  'fontWeight',\n  'letterSpacing',\n  'opacity',\n  'textDecoration',\n  'lineHeight',\n  'textAlign',\n  'visibility',\n  'wordSpacing',\n];\n\nexport const RULER_WIDTH = 13;\nexport const RULER_COLOR = 'white';\nexport const RULER_FONT_SIZE = 6;\nexport const DEFAULT_RULER_STEPS = 50;\nexport const LINE_WIDTH = 0.5;\nexport const LINE_COLOR = 'gray';\nexport const GRID_COLOR = '#ababab';\n","import * as R from 'ramda';\n\nimport { FONT_WEIGHTS } from '../constants';\n\nconst BOX_MODEL_REGEX = /\\d+(px|in|mm|cm|pt|%|vw|vh)?/g;\nconst OBJECT_POSITION_REGEX = /\\d+(px|in|mm|cm|pt|%|vw|vh)?/g;\nconst BORDER_SHORTHAND_REGEX = /(\\d+(px|in|mm|cm|pt|vw|vh)?)\\s(\\S+)\\s(\\S+)/;\nconst TRANSFORM_ORIGIN_REGEX = /(-?\\d+(px|in|mm|cm|pt|%|vw|vh)?)|top|right|bottom|left|center/g;\n\nconst matchBoxModel = R.match(BOX_MODEL_REGEX);\nconst matchObjectPosition = R.match(OBJECT_POSITION_REGEX);\nconst matchBorderShorthand = R.match(BORDER_SHORTHAND_REGEX);\nconst matchTransformOrigin = R.match(TRANSFORM_ORIGIN_REGEX);\n\nconst isFontWeightStyle = key => key.match(/^fontWeight/);\n\nconst isBorderStyle = (key, value) =>\n  key.match(/^border(Top|Right|Bottom|Left)(Color|Width|Style)/) &&\n  typeof value === 'string';\n\nconst isBoxModelStyle = (key, value) =>\n  key.match(/^(margin)|(padding)/) && typeof value === 'string';\n\nconst isObjectPositionStyle = (key, value) =>\n  key.match(/^objectPosition/) && typeof value === 'string';\n\nconst isTransformOriginStyle = (key, value) =>\n  key.match(/^transformOrigin/) && typeof value === 'string';\n\nconst processBorders = (key, value) => {\n  const match = matchBorderShorthand(value);\n\n  if (match) {\n    if (key.match(/.Color/)) {\n      return match[4];\n    } else if (key.match(/.Style/)) {\n      return match[3];\n    } else if (key.match(/.Width/)) {\n      return match[1];\n    } else {\n      throw new Error(`StyleSheet: Invalid '${value}' for '${key}'`);\n    }\n  }\n\n  return value;\n};\n\nconst processBoxModel = (key, value) => {\n  const match = matchBoxModel(value);\n\n  if (match) {\n    if (key.match(/.Top/)) {\n      return match[0];\n    } else if (key.match(/.Right/)) {\n      return match[1] || match[0];\n    } else if (key.match(/.Bottom/)) {\n      return match[2] || match[0];\n    } else if (key.match(/.Left/)) {\n      return match[3] || match[1] || match[0];\n    } else {\n      throw new Error(`StyleSheet: Invalid '${value}' for '${key}'`);\n    }\n  }\n\n  return value;\n};\n\nexport const processFontWeight = (key, value) => {\n  if (!value) return FONT_WEIGHTS.normal;\n  if (typeof value === 'number') return value;\n  return FONT_WEIGHTS[value.toLowerCase()];\n};\n\nexport const processObjectPosition = (key, value) => {\n  const match = matchObjectPosition(value);\n\n  if (match) {\n    if (key.match(/.X/)) {\n      return match[0];\n    } else if (key.match(/.Y/)) {\n      return match[1];\n    } else {\n      throw new Error(`StyleSheet: Invalid '${value}' for '${key}'`);\n    }\n  }\n\n  return value;\n};\n\nconst transformOffsetKeywords = value => {\n  switch (value) {\n    case 'top':\n    case 'left':\n      return '0%';\n    case 'right':\n    case 'bottom':\n      return '100%';\n    case 'center':\n      return '50%';\n    default:\n      return value;\n  }\n};\n\n// Transforms shorthand transformOrigin values\nconst processTransformOrigin = (key, value) => {\n  const match = matchTransformOrigin(value);\n\n  if (match) {\n    let result;\n\n    if (key.match(/.X/)) {\n      result = match[0];\n    } else if (key.match(/.Y/)) {\n      result = match[1] || match[0];\n    } else {\n      throw new Error(`StyleSheet: Invalid '${value}' for '${key}'`);\n    }\n\n    return transformOffsetKeywords(result);\n  }\n\n  return value;\n};\n\nconst matchNumber = R.when(\n  R.is(String),\n  R.compose(\n    R.complement(R.isEmpty),\n    R.match(/^-?\\d*\\.?\\d*$/),\n  ),\n);\n\nconst castFloat = R.when(matchNumber, v => parseFloat(v, 10));\n\nconst transformStyles = style => {\n  const propsArray = Object.keys(style);\n  const resolvedStyle = {};\n\n  for (let i = 0; i < propsArray.length; i++) {\n    const key = propsArray[i];\n    const value = style[key];\n\n    resolvedStyle[key] = R.compose(\n      castFloat,\n      R.cond([\n        [isBorderStyle, processBorders],\n        [isBoxModelStyle, processBoxModel],\n        [isObjectPositionStyle, processObjectPosition],\n        [isTransformOriginStyle, processTransformOrigin],\n        [isFontWeightStyle, processFontWeight],\n        [R.T, R.always(value)],\n      ]),\n    )(key, value);\n  }\n\n  return resolvedStyle;\n};\n\nexport default transformStyles;\n","import isUrl from 'is-url';\nimport fontkit from '@react-pdf/fontkit';\nimport fetch from 'cross-fetch';\n\nimport { processFontWeight } from '../stylesheet/transformStyles';\n\nconst fetchFont = async (src, options) => {\n  const response = await fetch(src, options);\n\n  const buffer = await (response.buffer\n    ? response.buffer()\n    : response.arrayBuffer());\n\n  return buffer.constructor.name === 'Buffer' ? buffer : Buffer.from(buffer);\n};\n\nclass FontSource {\n  constructor(src, fontFamily, fontStyle, fontWeight, options) {\n    this.src = src;\n    this.fontFamily = fontFamily;\n    this.fontStyle = fontStyle || 'normal';\n    this.fontWeight = processFontWeight(fontWeight) || 400;\n\n    this.data = null;\n    this.loading = false;\n    this.options = options;\n  }\n\n  async load() {\n    this.loading = true;\n\n    if (BROWSER || isUrl(this.src)) {\n      const { headers, body, method = 'GET' } = this.options;\n      const data = await fetchFont(this.src, { method, body, headers });\n      this.data = fontkit.create(data);\n    } else {\n      this.data = await new Promise((resolve, reject) =>\n        fontkit.open(this.src, (err, data) =>\n          err ? reject(err) : resolve(data),\n        ),\n      );\n    }\n\n    this.loading = false;\n  }\n}\n\nclass Font {\n  static create(family) {\n    return new Font(family);\n  }\n\n  constructor(family) {\n    this.family = family;\n    this.sources = [];\n  }\n\n  register({ src, fontWeight, fontStyle, ...options }) {\n    this.sources.push(\n      new FontSource(src, this.fontFamily, fontStyle, fontWeight, options),\n    );\n  }\n\n  resolve(descriptor) {\n    const { fontWeight = 400, fontStyle = 'normal' } = descriptor;\n    const styleSources = this.sources.filter(s => s.fontStyle === fontStyle);\n\n    // Weight resolution. https://developer.mozilla.org/en-US/docs/Web/CSS/font-weight#Fallback_weights\n    const exactFit = styleSources.find(s => s.fontWeight === fontWeight);\n\n    if (exactFit) return exactFit;\n\n    let res;\n\n    if (fontWeight >= 400 && fontWeight <= 500) {\n      const leftOffset = styleSources.filter(s => s.fontWeight <= fontWeight);\n      const rightOffset = styleSources.filter(s => s.fontWeight > 500);\n      const fit = styleSources.filter(\n        s => s.fontWeight >= fontWeight && s.fontWeight < 500,\n      );\n\n      res = fit[0] || leftOffset[leftOffset.length - 1] || rightOffset[0];\n    }\n\n    const lt = styleSources.filter(s => s.fontWeight < fontWeight);\n    const gt = styleSources.filter(s => s.fontWeight > fontWeight);\n\n    if (fontWeight < 400) {\n      res = lt[lt.length - 1] || gt[0];\n    }\n\n    if (fontWeight > 500) {\n      res = gt[0] || lt[lt.length - 1];\n    }\n\n    if (!res) {\n      throw new Error(\n        `Could not resolve font for ${\n          this.fontFamily\n        }, fontWeight ${fontWeight}`,\n      );\n    }\n\n    return res;\n  }\n}\n\nexport default Font;\n","export default [\n  'Courier',\n  'Courier-Bold',\n  'Courier-Oblique',\n  'Helvetica',\n  'Helvetica-Bold',\n  'Helvetica-Oblique',\n  'Times-Roman',\n  'Times-Bold',\n  'Times-Italic',\n];\n","function printWarning(format, ...args) {\n  let argIndex = 0;\n  const message = 'Warning: ' + format.replace(/%s/g, () => args[argIndex++]);\n\n  if (typeof console !== 'undefined') {\n    console.error(message);\n  }\n\n  try {\n    throw new Error(message);\n  } catch (x) {}\n}\n\nconst __DEV__ = process.env.NODE_ENV !== 'production';\n\nconst warning = __DEV__\n  ? (condition, format, ...args) => {\n      if (format === undefined) {\n        throw new Error(\n          '`warning(condition, format, ...args)` requires a warning ' +\n            'message argument',\n        );\n      }\n      if (!condition) {\n        printWarning(format, ...args);\n      }\n    }\n  : () => {};\n\nexport default warning;\n","import font from './font';\nimport emoji from './emoji';\nimport standardFonts from './standard';\nimport hyphenation from './hyphenation';\nimport warning from '../utils/warning';\n\nlet fonts = {};\n\nconst register = (src, data) => {\n  if (typeof src === 'object') {\n    data = src;\n  } else {\n    warning(\n      false,\n      'Font.register will not longer accept the font source as first argument. Please move it into the data object. For more info refer to https://react-pdf.org/fonts',\n    );\n\n    data.src = src;\n  }\n\n  const { family } = data;\n\n  if (!fonts[family]) {\n    fonts[family] = font.create(family);\n  }\n\n  // Bulk loading\n  if (data.fonts) {\n    for (let i = 0; i < data.fonts.length; i++) {\n      fonts[family].register({ family, ...data.fonts[i] });\n    }\n  } else {\n    fonts[family].register(data);\n  }\n};\n\nconst getRegisteredFonts = () => fonts;\n\nconst getRegisteredFontFamilies = () => Object.keys(fonts);\n\nconst getFont = descriptor => {\n  const { fontFamily } = descriptor;\n  const isStandard = standardFonts.includes(fontFamily);\n\n  if (isStandard) return null;\n\n  if (!fonts[fontFamily]) {\n    throw new Error(\n      `Font family not registered: ${fontFamily}. Please register it calling Font.register() method.`,\n    );\n  }\n\n  return fonts[fontFamily].resolve(descriptor);\n};\n\nconst load = async function(descriptor) {\n  const { fontFamily } = descriptor;\n  const isStandard = standardFonts.includes(fontFamily);\n\n  if (isStandard) return;\n\n  const font = getFont(descriptor);\n\n  // We cache the font to avoid fetching it many times\n  if (!font.data && !font.loading) {\n    await font.load();\n  }\n};\n\nconst reset = function() {\n  for (const font in fonts) {\n    if (fonts.hasOwnProperty(font)) {\n      fonts[font].data = null;\n    }\n  }\n};\n\nconst clear = function() {\n  fonts = {};\n};\n\nexport default {\n  register,\n  getRegisteredFonts,\n  getRegisteredFontFamilies,\n  getFont,\n  load,\n  clear,\n  reset,\n  ...emoji,\n  ...hyphenation,\n};\n","import * as R from 'ramda';\n\nimport { IMAGE } from '../constants';\n\n/**\n * Checks if node is image\n *\n * @param {Object} node\n * @returns {Boolean} is node image?\n */\nconst isImage = R.propEq('type', IMAGE);\n\nexport default isImage;\n","import PNG from '@react-pdf/png-js';\n\nPNG.isValid = function(data) {\n  try {\n    return !!new PNG(data);\n  } catch (e) {\n    return false;\n  }\n};\n\nexport default PNG;\n","// Extracted from https://github.com/devongovett/pdfkit/blob/master/lib/image/jpeg.coffee\n\nconst MARKERS = [\n  0xffc0,\n  0xffc1,\n  0xffc2,\n  0xffc3,\n  0xffc5,\n  0xffc6,\n  0xffc7,\n  0xffc8,\n  0xffc9,\n  0xffca,\n  0xffcb,\n  0xffcc,\n  0xffcd,\n  0xffce,\n  0xffcf,\n];\n\nclass JPEG {\n  data = null;\n  width = null;\n  height = null;\n\n  constructor(data) {\n    this.data = data;\n\n    if (data.readUInt16BE(0) !== 0xffd8) {\n      throw new Error('SOI not found in JPEG');\n    }\n\n    let marker;\n    let pos = 2;\n\n    while (pos < data.length) {\n      marker = data.readUInt16BE(pos);\n      pos += 2;\n      if (MARKERS.includes(marker)) {\n        break;\n      }\n      pos += data.readUInt16BE(pos);\n    }\n\n    if (!MARKERS.includes(marker)) {\n      throw new Error('Invalid JPEG.');\n    }\n\n    pos += 3;\n    this.height = data.readUInt16BE(pos);\n\n    pos += 2;\n    this.width = data.readUInt16BE(pos);\n  }\n}\n\nJPEG.isValid = function(data) {\n  if (!data || !Buffer.isBuffer(data) || data.readUInt16BE(0) !== 0xffd8) {\n    return false;\n  }\n\n  let marker;\n  let pos = 2;\n\n  while (pos < data.length) {\n    marker = data.readUInt16BE(pos);\n    pos += 2;\n    if (MARKERS.includes(marker)) {\n      break;\n    }\n    pos += data.readUInt16BE(pos);\n  }\n\n  if (!MARKERS.includes(marker)) {\n    return false;\n  }\n\n  return true;\n};\n\nexport default JPEG;\n","const createCache = ({ limit = 100 } = {}) => {\n  let cache = {};\n  let keys = [];\n\n  return {\n    get: key => cache[key],\n    set: (key, value) => {\n      keys.push(key);\n      if (keys.length > limit) {\n        delete cache[keys.shift()];\n      }\n      cache[key] = value;\n    },\n    reset: () => {\n      cache = {};\n      keys = [];\n    },\n    length: () => keys.length,\n  };\n};\n\nexport default createCache;\n","import fs from 'fs';\nimport url from 'url';\nimport path from 'path';\nimport fetch from 'cross-fetch';\n\nimport PNG from '../utils/png';\nimport JPEG from '../utils/jpeg';\nimport createCache from '../utils/cache';\n\nexport const IMAGE_CACHE = createCache({ limit: 30 });\n\nexport const getAbsoluteLocalPath = src => {\n  if (BROWSER) {\n    throw new Error('Cannot check local paths in client-side environment');\n  }\n\n  const { protocol, auth, host, port, hostname, path: pathname } = url.parse(\n    src,\n  );\n  const absolutePath = path.resolve(pathname);\n  if ((protocol && protocol !== 'file:') || auth || host || port || hostname) {\n    return undefined;\n  }\n  return absolutePath;\n};\n\nconst fetchLocalFile = src =>\n  new Promise((resolve, reject) => {\n    try {\n      if (BROWSER) {\n        return reject(new Error('Cannot fetch local file in this environemnt'));\n      }\n      const absolutePath = getAbsoluteLocalPath(src);\n      if (!absolutePath) {\n        return reject(new Error(`Cannot fetch non-local path: ${src}`));\n      }\n      fs.readFile(absolutePath, (err, data) =>\n        err ? reject(err) : resolve(data),\n      );\n    } catch (err) {\n      reject(err);\n    }\n  });\n\nconst fetchRemoteFile = async (uri, options) => {\n  const response = await fetch(uri, options);\n\n  const buffer = await (response.buffer\n    ? response.buffer()\n    : response.arrayBuffer());\n\n  return buffer.constructor.name === 'Buffer' ? buffer : Buffer.from(buffer);\n};\n\nconst isValidFormat = format => {\n  const lower = format.toLowerCase();\n  return lower === 'jpg' || lower === 'jpeg' || lower === 'png';\n};\n\nconst guessFormat = buffer => {\n  let format;\n\n  if (JPEG.isValid(buffer)) {\n    format = 'jpg';\n  } else if (PNG.isValid(buffer)) {\n    format = 'png';\n  }\n\n  return format;\n};\n\nconst isCompatibleBase64 = ({ uri }) =>\n  /^data:image\\/[a-zA-Z]*;base64,[^\"]*/g.test(uri);\n\nfunction getImage(body, extension) {\n  switch (extension.toLowerCase()) {\n    case 'jpg':\n    case 'jpeg':\n      return new JPEG(body);\n    case 'png':\n      return new PNG(body);\n    default:\n      return null;\n  }\n}\n\nconst resolveBase64Image = ({ uri }) => {\n  const match = /^data:image\\/([a-zA-Z]*);base64,([^\"]*)/g.exec(uri);\n  const format = match[1];\n  const data = match[2];\n\n  if (!isValidFormat(format)) {\n    throw new Error(`Base64 image invalid format: ${format}`);\n  }\n\n  return new Promise(resolve => {\n    return resolve(getImage(Buffer.from(data, 'base64'), format));\n  });\n};\n\nconst resolveImageFromData = src => {\n  if (src.data && src.format) {\n    return new Promise(resolve => resolve(getImage(src.data, src.format)));\n  }\n\n  throw new Error(`Invalid data given for local file: ${JSON.stringify(src)}`);\n};\n\nconst resolveBufferImage = buffer => {\n  const format = guessFormat(buffer);\n\n  if (format) {\n    return new Promise(resolve => resolve(getImage(buffer, format)));\n  }\n};\n\nconst getImageFormat = body => {\n  const isPng =\n    body[0] === 137 &&\n    body[1] === 80 &&\n    body[2] === 78 &&\n    body[3] === 71 &&\n    body[4] === 13 &&\n    body[5] === 10 &&\n    body[6] === 26 &&\n    body[7] === 10;\n\n  const isJpg = body[0] === 255 && body[1] === 216 && body[2] === 255;\n\n  let extension = '';\n  if (isPng) {\n    extension = 'png';\n  } else if (isJpg) {\n    extension = 'jpg';\n  } else {\n    throw new Error('Not valid image extension');\n  }\n\n  return extension;\n};\n\nconst resolveImageFromUrl = async src => {\n  const { uri, body, headers, method = 'GET' } = src;\n\n  const data =\n    !BROWSER && getAbsoluteLocalPath(uri)\n      ? await fetchLocalFile(uri)\n      : await fetchRemoteFile(uri, { body, headers, method });\n\n  const extension = getImageFormat(data);\n\n  return getImage(data, extension);\n};\n\nconst resolveImage = (src, { cache = true } = {}) => {\n  const cacheKey = src.data ? src.data.toString() : src.uri;\n\n  if (cache && IMAGE_CACHE.get(cacheKey)) {\n    return IMAGE_CACHE.get(cacheKey);\n  }\n\n  let image;\n  if (isCompatibleBase64(src)) {\n    image = resolveBase64Image(src);\n  } else if (Buffer.isBuffer(src)) {\n    image = resolveBufferImage(src);\n  } else if (typeof src === 'object' && src.data) {\n    image = resolveImageFromData(src);\n  } else {\n    image = resolveImageFromUrl(src);\n  }\n\n  if (!image) {\n    throw new Error('Cannot resolve image');\n  }\n\n  if (cache) {\n    IMAGE_CACHE.set(cacheKey, image);\n  }\n\n  return image;\n};\n\nexport default resolveImage;\n","import * as R from 'ramda';\n\n/**\n * Get image source\n *\n * @param {Object} image node\n * @returns {String} image src\n */\nconst getSource = R.compose(\n  R.when(R.is(String), src => ({ uri: src })),\n  R.either(R.path(['props', 'src']), R.path(['props', 'source'])),\n);\n\nexport default getSource;\n","import resolveImage from './resolveImage';\nimport getSource from './getSource';\nimport warning from '../utils/warning';\n\nconst fetchImage = async node => {\n  const src = getSource(node);\n  const { cache } = node.props;\n\n  if (!src) {\n    warning(false, 'Image should receive either a \"src\" or \"source\" prop');\n    return;\n  }\n\n  try {\n    node.image = await resolveImage(src, { cache });\n  } catch (e) {\n    node.image = { width: 0, height: 0 };\n    console.warn(e.message);\n  }\n};\n\nexport default fetchImage;\n","/* eslint-disable no-cond-assign */\nimport emojiRegex from 'emoji-regex';\n\nimport Font from '../font';\nimport resolveImage from '../image/resolveImage';\n\n// Caches emoji images data\nconst emojis = {};\nconst regex = emojiRegex();\n\nconst reflect = promise => (...args) => promise(...args).then(v => v, e => e);\n\n// Returns a function to be able to mock resolveImage.\nconst makeFetchEmojiImage = () => reflect(resolveImage);\n\n/**\n * When an emoji as no color, it might still have 2 parts,\n * the canonical emoji and an empty string.\n * ex.\n *   (no color) Array.from('❤️') => [\"❤\", \"️\"]\n *   (w/ color) Array.from('👍🏿') => [\"👍\", \"🏿\"]\n *\n * The empty string needs to be removed otherwise the generated\n * url will be incorect.\n */\nconst _removeNoColor = x => x !== '️';\n\nconst getCodePoints = string =>\n  Array.from(string)\n    .filter(_removeNoColor)\n    .map(char => char.codePointAt(0).toString(16))\n    .join('-');\n\nconst buildEmojiUrl = emoji => {\n  const { url, format } = Font.getEmojiSource();\n  return `${url}${getCodePoints(emoji)}.${format}`;\n};\n\nexport const fetchEmojis = string => {\n  const emojiSource = Font.getEmojiSource();\n\n  if (!emojiSource || !emojiSource.url) return [];\n\n  const promises = [];\n\n  let match;\n  while ((match = regex.exec(string))) {\n    const emoji = match[0];\n\n    if (!emojis[emoji] || emojis[emoji].loading) {\n      const emojiUrl = buildEmojiUrl(emoji);\n\n      emojis[emoji] = { loading: true };\n      const fetchEmojiImage = makeFetchEmojiImage();\n      promises.push(\n        fetchEmojiImage({ uri: emojiUrl }).then(image => {\n          emojis[emoji].loading = false;\n          emojis[emoji].data = image.data;\n        }),\n      );\n    }\n  }\n\n  return promises;\n};\n\nexport const embedEmojis = fragments => {\n  const result = [];\n\n  for (let i = 0; i < fragments.length; i++) {\n    const fragment = fragments[i];\n\n    let match;\n    let lastIndex = 0;\n\n    while ((match = regex.exec(fragment.string))) {\n      const index = match.index;\n      const emoji = match[0];\n      const emojiSize = fragment.attributes.fontSize;\n      const chunk = fragment.string.slice(lastIndex, index + match[0].length);\n\n      // If emoji image was found, we create a new fragment with the\n      // correct attachment and object substitution character;\n      if (emojis[emoji] && emojis[emoji].data) {\n        result.push({\n          string: chunk.replace(match, String.fromCharCode(0xfffc)),\n          attributes: {\n            ...fragment.attributes,\n            attachment: {\n              width: emojiSize,\n              height: emojiSize,\n              yOffset: Math.floor(emojiSize * 0.1),\n              image: emojis[emoji].data,\n            },\n          },\n        });\n      } else {\n        // If no emoji data, we just replace the emoji with a nodef char\n        result.push({\n          string: chunk.replace(match, String.fromCharCode(0)),\n          attributes: fragment.attributes,\n        });\n      }\n\n      lastIndex = index + emoji.length;\n    }\n\n    if (lastIndex < fragment.string.length) {\n      result.push({\n        string: fragment.string.slice(lastIndex),\n        attributes: fragment.attributes,\n      });\n    }\n  }\n\n  return result;\n};\n","import * as R from 'ramda';\n\nimport Font from '../font';\nimport isImage from '../node/isImage';\nimport fetchImage from '../image/fetchImage';\nimport { fetchEmojis } from '../text/emoji';\n\n/**\n * Get all asset promises that need to be resolved\n *\n * @param {Object} root node\n * @returns {Array} asset promises\n */\nconst fetchAssets = node => {\n  const promises = [];\n  const listToExplore = node.children.slice(0);\n\n  while (listToExplore.length > 0) {\n    const node = listToExplore.shift();\n\n    if (isImage(node)) {\n      promises.push(fetchImage(node));\n    }\n\n    if (node.style && node.style.fontFamily) {\n      promises.push(Font.load(node.style));\n    }\n\n    if (typeof node === 'string') {\n      promises.push(...fetchEmojis(node));\n    }\n\n    if (typeof node.value === 'string') {\n      promises.push(...fetchEmojis(node.value));\n    }\n\n    if (node.children) {\n      node.children.forEach(childNode => {\n        listToExplore.push(childNode);\n      });\n    }\n  }\n\n  return promises;\n};\n\n/**\n * Fetch image, font and emoji assets in parallel.\n * Layout process will not be resumed until promise resolves.\n *\n * @param {Object} root node\n * @returns {Object} root node\n */\nconst resolveAssets = node =>\n  R.compose(\n    R.then(R.always(node)),\n    p => Promise.all(p),\n    fetchAssets,\n  )(node);\n\nexport default resolveAssets;\n","import * as R from 'ramda';\n\n/**\n * Remove nil values from array\n *\n * @param {Array} array\n * @returns {Array} array without nils\n */\nconst compact = R.filter(Boolean);\n\n/**\n * Checks if value is array\n *\n * @param {any} value\n * @returns {Boolean} is value an array\n */\nconst isArray = R.is(Array);\n\n/**\n * Checks if value is not an array\n *\n * @param {any} value\n * @returns {Boolean} isn't value an array\n */\nconst isNotArray = R.complement(isArray);\n\n/**\n * Casts value to array\n *\n * @param {any} value\n * @returns {Array} casted value\n */\nconst castArray = R.when(isNotArray, v => [v]);\n\n/**\n * Merges style objects array\n *\n * @param {Array} style objects array\n * @returns {Object} merged style object\n */\nconst mergeStyles = styles =>\n  styles.reduce((acc, style) => {\n    const s = isArray(style) ? flatten(style) : style;\n\n    Object.keys(s).forEach(key => {\n      if (s[key] !== null && s[key] !== undefined) {\n        acc[key] = s[key];\n      }\n    });\n\n    return acc;\n  }, {});\n\n/**\n * Flattens an array of style objects, into one aggregated style object.\n *\n * @param {Array} style objects array\n * @returns {Object} flatted style object\n */\nconst flatten = R.compose(\n  mergeStyles,\n  compact,\n  castArray,\n);\n\nexport default flatten;\n","import * as R from 'ramda';\n\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\n\n/**\n * Expand rules\n */\nconst styleShorthands = {\n  margin: {\n    marginTop: true,\n    marginRight: true,\n    marginBottom: true,\n    marginLeft: true,\n  },\n  marginHorizontal: {\n    marginLeft: true,\n    marginRight: true,\n  },\n  marginVertical: {\n    marginTop: true,\n    marginBottom: true,\n  },\n  padding: {\n    paddingTop: true,\n    paddingRight: true,\n    paddingBottom: true,\n    paddingLeft: true,\n  },\n  paddingHorizontal: {\n    paddingLeft: true,\n    paddingRight: true,\n  },\n  paddingVertical: {\n    paddingTop: true,\n    paddingBottom: true,\n  },\n  border: {\n    borderTopColor: true,\n    borderTopStyle: true,\n    borderTopWidth: true,\n    borderRightColor: true,\n    borderRightStyle: true,\n    borderRightWidth: true,\n    borderBottomColor: true,\n    borderBottomStyle: true,\n    borderBottomWidth: true,\n    borderLeftColor: true,\n    borderLeftStyle: true,\n    borderLeftWidth: true,\n  },\n  borderTop: {\n    borderTopColor: true,\n    borderTopStyle: true,\n    borderTopWidth: true,\n  },\n  borderRight: {\n    borderRightColor: true,\n    borderRightStyle: true,\n    borderRightWidth: true,\n  },\n  borderBottom: {\n    borderBottomColor: true,\n    borderBottomStyle: true,\n    borderBottomWidth: true,\n  },\n  borderLeft: {\n    borderLeftColor: true,\n    borderLeftStyle: true,\n    borderLeftWidth: true,\n  },\n  borderColor: {\n    borderTopColor: true,\n    borderRightColor: true,\n    borderBottomColor: true,\n    borderLeftColor: true,\n  },\n  borderRadius: {\n    borderTopLeftRadius: true,\n    borderTopRightRadius: true,\n    borderBottomRightRadius: true,\n    borderBottomLeftRadius: true,\n  },\n  borderStyle: {\n    borderTopStyle: true,\n    borderRightStyle: true,\n    borderBottomStyle: true,\n    borderLeftStyle: true,\n  },\n  borderWidth: {\n    borderTopWidth: true,\n    borderRightWidth: true,\n    borderBottomWidth: true,\n    borderLeftWidth: true,\n  },\n  objectPosition: {\n    objectPositionX: true,\n    objectPositionY: true,\n  },\n  transformOrigin: {\n    transformOriginX: true,\n    transformOriginY: true,\n  },\n};\n\nconst expandedKeys = R.keys(styleShorthands);\n\n/**\n * Expand the shorthand properties to isolate every declaration from the others.\n *\n * @param { Object } style object\n * @returns { Object } expanded style object\n */\nconst expandStyles = style => {\n  if (!style) return style;\n\n  const propsArray = Object.keys(style);\n  const resolvedStyle = {};\n\n  for (let i = 0; i < propsArray.length; i++) {\n    const key = propsArray[i];\n    const value = style[key];\n\n    if (R.includes(key, expandedKeys)) {\n      const expandedProps = styleShorthands[key];\n      for (const propName in expandedProps) {\n        if (hasOwnProperty.call(expandedProps, propName)) {\n          resolvedStyle[propName] = value;\n        }\n      }\n    } else {\n      resolvedStyle[key] = value;\n    }\n  }\n\n  return resolvedStyle;\n};\n\nexport default expandStyles;\n","import * as R from 'ramda';\n\nimport { DPI } from '../constants';\n\n/**\n * Parses scalar value in value and unit pairs\n *\n * @param {String} scalar value\n * @returns {Object} parsed value\n */\nconst parseValue = value => {\n  const match = /^(-?\\d*\\.?\\d+)(in|mm|cm|pt|vh|vw)?$/g.exec(value);\n  return match\n    ? { value: parseFloat(match[1], 10), unit: match[2] || 'pt' }\n    : { value, unit: undefined };\n};\n\n/**\n * Transform given scalar value\n *\n * @param {Object} container\n * @param {String} styles value\n * @returns {Object} transformed value\n */\nconst transformUnit = R.curryN(2, (container, value) => {\n  const scalar = parseValue(value);\n  switch (scalar.unit) {\n    case 'in':\n      return scalar.value * DPI;\n    case 'mm':\n      return scalar.value * (1 / 25.4) * DPI;\n    case 'cm':\n      return scalar.value * (1 / 2.54) * DPI;\n    case 'vh':\n      return scalar.value * (container.height / 100);\n    case 'vw':\n      return scalar.value * (container.width / 100);\n    default:\n      return scalar.value;\n  }\n});\n\n/**\n * Transform units on given styles object.\n * Container is given to calculate vh and vw\n *\n * @param {Object} container\n * @param {Object} styles object\n * @returns {Object} transformed styles\n */\nconst transformUnits = (container, styles) =>\n  R.map(transformUnit(container), styles);\n\nexport default R.curryN(2, transformUnits);\n","import * as R from 'ramda';\nimport matchMedia from 'media-engine';\n\n/**\n * Resolves media queries in styles object\n *\n * @param {Object} container\n * @param {Object} styles object\n */\nconst resolveMediaQueries = (container, styles) => {\n  return Object.keys(styles).reduce((acc, key) => {\n    if (/@media/.test(key)) {\n      return {\n        ...acc,\n        ...matchMedia({ [key]: styles[key] }, container),\n      };\n    }\n\n    return { ...acc, [key]: styles[key] };\n  }, {});\n};\n\nexport default R.curryN(2, resolveMediaQueries);\n","import * as R from 'ramda';\n\nimport flattenStyles from '../stylesheet/flatten';\nimport expandStyles from '../stylesheet/expandStyles';\nimport transformUnits from '../stylesheet/transformUnits';\nimport transformStyles from '../stylesheet/transformStyles';\nimport resolveMediaQueries from '../stylesheet/resolveMediaQueries';\n\n/**\n * Resolves styles\n *\n * @param {Object} container\n * @param {Object} style object\n * @returns {Object} resolved style object\n */\nconst resolveStyles = container =>\n  R.compose(\n    transformUnits(container),\n    transformStyles,\n    expandStyles,\n    resolveMediaQueries(container),\n    flattenStyles,\n  );\n\n/**\n * Resolves node styles\n *\n * @param {Object} container\n * @param {Object} document node\n * @returns {Object} node (and subnodes) with resolved styles\n */\nconst resolveNodeStyles = page => node => {\n  const container = R.propOr({}, 'box', page);\n\n  return R.evolve({\n    style: resolveStyles(container),\n    children: R.map(resolveNodeStyles(page)),\n  })(node);\n};\n\n/**\n * Resolves page styles\n *\n * @param {Object} document page\n * @returns {Object} document page with resolved styles\n */\nconst resolvePageStyles = page => {\n  const pageBox = R.propOr({}, 'box', page);\n\n  return R.evolve({\n    children: R.map(resolveNodeStyles(page)),\n    style: R.compose(\n      transformUnits(pageBox),\n      transformStyles,\n      expandStyles,\n      flattenStyles,\n    ),\n  })(page);\n};\n\n/**\n * Resolves root styles\n *\n * @param {Object} document root\n * @returns {Object} document root with resolved styles\n */\nexport default R.evolve({\n  children: R.map(\n    R.evolve({\n      children: R.map(resolvePageStyles),\n    }),\n  ),\n});\n","import * as R from 'ramda';\n\n/**\n * Sort children by zIndex value\n *\n * @param {Object} node\n * @returns {Object} node\n */\nconst resolveZIndex = node =>\n  R.evolve({\n    children: R.compose(\n      R.map(resolveZIndex),\n      R.sortBy(R.path(['style', 'zIndex'])),\n    ),\n  })(node);\n\nexport default resolveZIndex;\n","import * as R from 'ramda';\n\n/**\n * Checks if page should render vertical ruler\n *\n * @param {Object} page\n * @returns {boolean} has vertical ruler\n */\nconst hasVerticalRuler = R.either(\n  R.hasPath(['props', 'ruler']),\n  R.hasPath(['props', 'verticalRuler']),\n);\n\nexport default hasVerticalRuler;\n","import * as R from 'ramda';\n\n/**\n * Checks if page should render horizontal ruler\n *\n * @param {Object} page\n * @returns {boolean} has horizontal ruler\n */\nconst hasHorizontalRuler = R.either(\n  R.hasPath(['props', 'ruler']),\n  R.hasPath(['props', 'horizontalRuler']),\n);\n\nexport default hasHorizontalRuler;\n","import * as R from 'ramda';\n\nimport { RULER_WIDTH } from '../constants';\nimport hasVerticalRuler from '../node/hasVerticalRuler';\nimport hasHorizontalRuler from '../node/hasHorizontalRuler';\n\n/**\n * Adjust page size given ruler props\n *\n * @param {Object} page\n * @returns {boolean} page with size altered by ruler props\n */\nconst adjustPageSize = R.compose(\n  R.when(\n    hasVerticalRuler,\n    R.evolve({\n      box: { height: R.add(RULER_WIDTH) },\n      children: R.map(\n        R.evolve({\n          box: { top: R.add(RULER_WIDTH) },\n        }),\n      ),\n    }),\n  ),\n  R.when(\n    hasHorizontalRuler,\n    R.evolve({\n      box: { width: R.add(RULER_WIDTH) },\n      children: R.map(\n        R.evolve({\n          box: { left: R.add(RULER_WIDTH) },\n        }),\n      ),\n    }),\n  ),\n);\n\n/**\n * Adjust pages size given ruler props\n *\n * @param {Object} root\n * @returns {boolean} root with pages size altered by ruler props\n */\nconst resolveRulers = R.evolve({\n  children: R.map(\n    R.evolve({\n      children: R.map(adjustPageSize),\n    }),\n  ),\n});\n\nexport default resolveRulers;\n","const isPercent = value => /((-)?\\d+\\.?\\d*)%/g.exec(value);\n\n/**\n * Get percentage value of input\n *\n * @param {String} value\n * @returns {Object} percent value (if matches)\n */\nconst matchPercent = value => {\n  const match = isPercent(value);\n\n  if (match) {\n    const value = parseFloat(match[1], 10);\n    const percent = value / 100;\n\n    return {\n      value,\n      percent,\n      absValue: Math.abs(value),\n      absPercent: Math.abs(percent),\n    };\n  }\n\n  return null;\n};\n\nexport default matchPercent;\n","import * as R from 'ramda';\n\nimport matchPercent from '../utils/matchPercent';\n\nconst getTransformStyle = s => R.pathOr('50%', ['style', s]);\n\n/**\n * Get node origin\n *\n * @param {Object} node\n * @returns {Object} node origin\n */\nconst getOrigin = node => {\n  if (!node.box) return {};\n\n  const { left, top, width, height } = node.box;\n  const transformOriginX = getTransformStyle('transformOriginX')(node);\n  const transformOriginY = getTransformStyle('transformOriginY')(node);\n\n  const percentX = matchPercent(transformOriginX);\n  const percentY = matchPercent(transformOriginY);\n\n  const offsetX = percentX ? width * percentX.percent : transformOriginX;\n  const offsetY = percentY ? height * percentY.percent : transformOriginY;\n\n  return { left: left + offsetX, top: top + offsetY };\n};\n\nexport default getOrigin;\n","import * as R from 'ramda';\n\nimport getOrigin from '../node/getOrigin';\n\n/**\n * Resolve node origin\n *\n * @param {Object} node\n * @returns {Object} node with origin attribute\n */\nconst resolveNodeOrigin = node =>\n  R.compose(\n    R.evolve({ children: R.map(resolveNodeOrigin) }),\n    R.converge(R.assoc('origin'), [getOrigin, R.identity]),\n  )(node);\n\n/**\n * Resolve document origins\n *\n * @param {Object} document root\n * @returns {Object} documrnt root\n */\nconst resolveOrigin = R.evolve({\n  children: R.map(\n    R.evolve({\n      children: R.map(resolveNodeOrigin),\n    }),\n  ),\n});\n\nexport default resolveOrigin;\n","import * as R from 'ramda';\n\nimport { PORTRAIT, LANDSCAPE } from '../constants';\n\nconst VALID_ORIENTATIONS = [PORTRAIT, LANDSCAPE];\n\n/**\n * Get page orientation. Defaults to landscape\n *\n * @param { Object } page object\n * @returns { String } page orientation\n */\nconst getOrientation = R.compose(\n  R.ifElse(\n    R.includes(R.__, VALID_ORIENTATIONS),\n    R.identity,\n    R.always(PORTRAIT),\n  ),\n  R.pathOr(PORTRAIT, ['props', 'orientation']),\n);\n\nexport default getOrientation;\n","import * as R from 'ramda';\n\nimport getOrientation from './getOrientation';\n\nimport { LANDSCAPE } from '../constants';\n\nconst isLandscape = R.compose(\n  R.equals(LANDSCAPE),\n  getOrientation,\n);\n\nexport default isLandscape;\n","import * as R from 'ramda';\n\nimport isLandscape from './isLandscape';\nimport { PAGE_SIZES } from '../constants';\n\n/**\n * Transforms array into size object\n *\n * @param {Array} array\n * @returns {Object} size object with width and height\n */\nconst toSizeObject = R.applySpec({\n  width: R.prop(0),\n  height: R.prop(1),\n});\n\n/**\n * Flip size object\n *\n * @param {Object} size object\n * @returns {Object} flipped size object\n */\nconst flipSizeObject = R.applySpec({\n  width: R.prop('height'),\n  height: R.prop('width'),\n});\n\n/**\n * Returns size object from a given string\n *\n * @param {String} page size string\n * @returns {Object} size object with width and height\n */\nconst getStringSize = R.compose(\n  toSizeObject,\n  R.prop(R.__, PAGE_SIZES),\n  R.toUpper,\n);\n\n/**\n * Returns size object from a single number\n *\n * @param {Number} page size number\n * @returns {Object} size object with width and height\n */\nconst getNumberSize = R.compose(\n  toSizeObject,\n  v => [v],\n);\n\n/**\n * Throws invalid size error\n *\n * @param {String} invalid page size input\n */\nconst throwInvalidError = size => {\n  throw new Error(`Invalid Page size: ${JSON.stringify(size)}`);\n};\n\n/**\n * Return page size in an object { width, height }\n *\n * @param {Object} page instance\n * @returns {Object} size object with width and height\n */\nconst getSize = page => {\n  const size = R.compose(\n    R.cond([\n      [R.is(String), getStringSize],\n      [R.is(Array), toSizeObject],\n      [R.is(Number), getNumberSize],\n      [R.is(Object), R.identity],\n      [R.T, throwInvalidError],\n    ]),\n    R.pathOr('A4', ['props', 'size']),\n  )(page);\n\n  return isLandscape(page) ? flipSizeObject(size) : size;\n};\n\nexport default getSize;\n","import * as R from 'ramda';\n\n/**\n * Add empt box prop if not present in node\n *\n * @param {Object} node\n * @returns {Object} node with box prop\n */\nconst assocIfNil = (key, value, target) =>\n  R.when(\n    R.compose(\n      R.isNil,\n      R.prop(key),\n    ),\n    R.assoc(key, value),\n  )(target);\n\nexport default R.curryN(3, assocIfNil);\n","import * as R from 'ramda';\n\nimport getPageSize from '../page/getSize';\nimport assocIfNil from '../utils/assocIfNil';\n\n/**\n * Resolves page size\n *\n * @param {Object} page\n * @returns {Object} page with resolved size in style attribute\n */\nexport const resolvePageSize = key => page => {\n  const size = getPageSize(page);\n  return R.evolve({ [key]: R.merge(R.__, size) })(page);\n};\n\n/**\n * Resolves page sizes\n *\n * @param {Object} document root\n * @returns {Object} document root with resolved page sizes\n */\nconst resolvePageSizes = key => R.evolve({\n  children: R.map(\n    R.evolve({\n      children: R.map(\n        R.compose(\n          resolvePageSize(key),\n          assocIfNil(key, {}),\n        ),\n      ),\n    }),\n  ),\n});\n\nexport default resolvePageSizes;\n","import * as R from 'ramda';\n\nconst isNotNil = R.complement(R.isNil);\n\n/**\n * Takes a list of predicates and returns the first predicate result that returns true for a given list of arguments\n *\n * @param  {...any} predicates\n * @param  {any} value\n */\nconst firstPass = (...fns) => value => {\n  let res;\n\n  for (const fn of fns) {\n    res = fn(value);\n    if (isNotNil(res)) return res;\n  }\n\n  return res;\n};\n\nexport default firstPass;\n","import * as R from 'ramda';\nimport Yoga from 'yoga-layout';\n\nimport firstPass from '../utils/firstPass';\n\nconst getComputedMargin = edge => node => {\n  const yogaNode = node._yogaNode;\n  return yogaNode ? yogaNode.getComputedMargin(edge) : null;\n};\n\n/**\n * Get Yoga computed magins. Zero otherwise\n *\n * @param {Object} node\n * @return {Object} margins\n */\nconst getMargin = R.applySpec({\n  marginTop: firstPass(\n    getComputedMargin(Yoga.EDGE_TOP),\n    R.path(['box', 'marginTop']),\n    R.path(['style', 'marginTop']),\n    R.path(['style', 'marginVertical']),\n    R.path(['style', 'margin']),\n    R.always(0),\n  ),\n  marginRight: firstPass(\n    getComputedMargin(Yoga.EDGE_RIGHT),\n    R.path(['box', 'marginRight']),\n    R.path(['style', 'marginRight']),\n    R.path(['style', 'marginHorizontal']),\n    R.path(['style', 'margin']),\n    R.always(0),\n  ),\n  marginBottom: firstPass(\n    getComputedMargin(Yoga.EDGE_BOTTOM),\n    R.path(['box', 'marginBottom']),\n    R.path(['style', 'marginBottom']),\n    R.path(['style', 'marginVertical']),\n    R.path(['style', 'margin']),\n    R.always(0),\n  ),\n  marginLeft: firstPass(\n    getComputedMargin(Yoga.EDGE_LEFT),\n    R.path(['box', 'marginLeft']),\n    R.path(['style', 'marginLeft']),\n    R.path(['style', 'marginHorizontal']),\n    R.path(['style', 'margin']),\n    R.always(0),\n  ),\n});\n\nexport default getMargin;\n","import * as R from 'ramda';\nimport Yoga from 'yoga-layout';\n\nimport firstPass from '../utils/firstPass';\n\nconst getComputedPadding = edge => node => {\n  const yogaNode = node._yogaNode;\n  return yogaNode ? yogaNode.getComputedPadding(edge) : null;\n};\n\n/**\n * Get Yoga computed magins. Zero otherwise\n *\n * @param {Object} node\n * @return {Object} paddings\n */\nconst getPadding = R.applySpec({\n  paddingTop: firstPass(\n    getComputedPadding(Yoga.EDGE_TOP),\n    R.path(['box', 'paddingTop']),\n    R.path(['style', 'paddingTop']),\n    R.path(['style', 'paddingVertical']),\n    R.path(['style', 'padding']),\n    R.always(0),\n  ),\n  paddingRight: firstPass(\n    getComputedPadding(Yoga.EDGE_RIGHT),\n    R.path(['box', 'paddingRight']),\n    R.path(['style', 'paddingRight']),\n    R.path(['style', 'paddingHorizontal']),\n    R.path(['style', 'padding']),\n    R.always(0),\n  ),\n  paddingBottom: firstPass(\n    getComputedPadding(Yoga.EDGE_BOTTOM),\n    R.path(['box', 'paddingBottom']),\n    R.path(['style', 'paddingBottom']),\n    R.path(['style', 'paddingVertical']),\n    R.path(['style', 'padding']),\n    R.always(0),\n  ),\n  paddingLeft: firstPass(\n    getComputedPadding(Yoga.EDGE_LEFT),\n    R.path(['box', 'paddingLeft']),\n    R.path(['style', 'paddingLeft']),\n    R.path(['style', 'paddingHorizontal']),\n    R.path(['style', 'padding']),\n    R.always(0),\n  ),\n});\n\nexport default getPadding;\n","import * as R from 'ramda';\n\nconst getTop = yogaNode => (yogaNode ? yogaNode.getComputedTop() : 0);\nconst getRight = yogaNode => (yogaNode ? yogaNode.getComputedRight() : 0);\nconst getBottom = yogaNode => (yogaNode ? yogaNode.getComputedBottom() : 0);\nconst getLeft = yogaNode => (yogaNode ? yogaNode.getComputedLeft() : 0);\n\n/**\n * Get Yoga computed position. Zero otherwise\n *\n * @param {Object} node\n * @return {Object} position\n */\nconst getPosition = node => {\n  const yogaNode = node._yogaNode;\n\n  return R.applySpec({\n    top: getTop,\n    right: getRight,\n    bottom: getBottom,\n    left: getLeft,\n  })(yogaNode);\n};\n\nexport default getPosition;\n","const DEFAULT_DIMENSION = {\n  width: 0,\n  height: 0,\n};\n\n/**\n * Get Yoga computed dimensions. Zero otherwise\n *\n * @param {Object} node\n * @return {Object} dimensions\n */\nconst getDimension = node => {\n  const yogaNode = node._yogaNode;\n\n  if (!yogaNode) return DEFAULT_DIMENSION;\n\n  return {\n    width: yogaNode.getComputedWidth(),\n    height: yogaNode.getComputedHeight(),\n  };\n};\n\nexport default getDimension;\n","import * as R from 'ramda';\nimport Yoga from 'yoga-layout';\n\nconst getComputedBorder = edge => yogaNode =>\n  yogaNode ? yogaNode.getComputedBorder(edge) : 0;\n\n/**\n * Get Yoga computed border width. Zero otherwise\n *\n * @param {Object} node\n * @return {Object} border widths\n */\nconst getBorderWidth = node => {\n  const yogaNode = node._yogaNode;\n\n  return R.applySpec({\n    borderTopWidth: getComputedBorder(Yoga.EDGE_TOP),\n    borderRightWidth: getComputedBorder(Yoga.EDGE_RIGHT),\n    borderBottomWidth: getComputedBorder(Yoga.EDGE_BOTTOM),\n    borderLeftWidth: getComputedBorder(Yoga.EDGE_LEFT),\n  })(yogaNode);\n};\n\nexport default getBorderWidth;\n","import * as R from 'ramda';\n\n/**\n * Capitalize first letter of string\n *\n * @param {String} string\n * @returns {String} capitalized string\n */\nconst upperFirst = R.ifElse(\n  R.isNil,\n  R.identity,\n  R.compose(\n    R.join(''),\n    R.juxt([\n      R.compose(\n        R.toUpper,\n        R.head,\n      ),\n      R.tail,\n    ]),\n  ),\n);\n\nexport default upperFirst;\n","import * as R from 'ramda';\n\nimport upperFirst from '../utils/upperFirst';\nimport matchPercent from '../utils/matchPercent';\n\n/**\n * Set generic yoga attribute to node's Yoga instance, handing `auto`, edges and percentage cases\n *\n * @param {String} property\n * @param {Number} edge\n * @param {any} value\n * @param {Object} node instance\n * @return {Object} node instance\n */\nconst setYogaValue = (attr, edge) => value =>\n  R.tap(node => {\n    const yogaNode = node._yogaNode;\n\n    if (!R.isNil(value) && yogaNode) {\n      const hasEdge = R.complement(R.isNil)(edge);\n      const fixedMethod = `set${upperFirst(attr)}`;\n      const autoMethod = `${fixedMethod}Auto`;\n      const percentMethod = `${fixedMethod}Percent`;\n      const percent = matchPercent(value);\n\n      if (percent && !yogaNode[percentMethod]) {\n        throw new Error(`You can't pass percentage values to ${attr} property`);\n      }\n\n      if (percent) {\n        hasEdge\n          ? yogaNode[percentMethod](edge, percent.value)\n          : yogaNode[percentMethod](percent.value);\n      } else if (value === 'auto') {\n        hasEdge ? yogaNode[autoMethod](edge) : yogaNode[autoMethod]();\n      } else {\n        hasEdge\n          ? yogaNode[fixedMethod](edge, value)\n          : yogaNode[fixedMethod](value);\n      }\n    }\n  });\n\nexport default setYogaValue;\n","import setYogaValue from './setYogaValue';\n\n/**\n * Set flex attribute to node's Yoga instance\n *\n * @param {Number} flex value\n * @param {Object} node instance\n * @return {Object} node instance\n */\nconst setFlex = setYogaValue('flex');\n\nexport default setFlex;\n","import * as R from 'ramda';\nimport Yoga from 'yoga-layout';\n\n/**\n * Set display attribute to node's Yoga instance\n *\n * @param {String} display\n * @param {Object} node instance\n * @return {Object} node instance\n */\nconst setDisplay = value =>\n  R.tap(node => {\n    const yogaNode = node._yogaNode;\n\n    if (yogaNode) {\n      yogaNode.setDisplay(\n        value === 'none' ? Yoga.DISPLAY_NONE : Yoga.DISPLAY_FLEX,\n      );\n    }\n  });\n\nexport default setDisplay;\n","import * as R from 'ramda';\nimport Yoga from 'yoga-layout';\n\n/**\n * Set overflow attribute to node's Yoga instance\n *\n * @param {String} overflow value\n * @param {Object} node instance\n * @return {Object} node instance\n */\nconst setOverflow = value =>\n  R.tap(node => {\n    const yogaNode = node._yogaNode;\n\n    if (!R.isNil(value) && yogaNode) {\n      const yogaValue = R.cond([\n        [R.equals('hidden'), R.always(Yoga.OVERFLOW_HIDDEN)],\n        [R.equals('scroll'), R.always(Yoga.OVERFLOW_SCROLL)],\n        [R.T, R.always(Yoga.OVERFLOW_VISIBLE)],\n      ])(value);\n\n      yogaNode.setOverflow(yogaValue);\n    }\n  });\n\nexport default setOverflow;\n","import * as R from 'ramda';\nimport Yoga from 'yoga-layout';\n\n/**\n * Set flex wrap attribute to node's Yoga instance\n *\n * @param {String} flex wrap value\n * @param {Object} node instance\n * @return {Object} node instance\n */\nconst setFlexWrap = value =>\n  R.tap(node => {\n    const yogaNode = node._yogaNode;\n\n    if (yogaNode) {\n      const yogaValue = R.cond([\n        [R.equals('wrap'), R.always(Yoga.WRAP_WRAP)],\n        [R.equals('wrap-reverse'), R.always(Yoga.WRAP_WRAP_REVERSE)],\n        [R.T, R.always(Yoga.WRAP_NO_WRAP)],\n      ])(value);\n\n      yogaNode.setFlexWrap(yogaValue);\n    }\n  });\n\nexport default setFlexWrap;\n","import * as R from 'ramda';\n\nimport setYogaValue from './setYogaValue';\n\n/**\n * Set flex grow attribute to node's Yoga instance\n *\n * @param {Number} flex grow value\n * @param {Object} node instance\n * @return {Object} node instance\n */\nconst setFlexGrow = R.compose(\n  setYogaValue('flexGrow'),\n  R.defaultTo(0),\n);\n\nexport default setFlexGrow;\n","import setYogaValue from './setYogaValue';\n\n/**\n * Set flex basis attribute to node's Yoga instance\n *\n * @param {Number} flex basis value\n * @param {Object} node instance\n * @return {Object} node instance\n */\nconst setFlexBasis = setYogaValue('flexBasis');\n\nexport default setFlexBasis;\n","import * as R from 'ramda';\nimport Yoga from 'yoga-layout';\n\nimport upperFirst from '../utils/upperFirst';\n\n/**\n * Set generic align attribute to node's Yoga instance\n *\n * @param {String} specific align property\n * @param {String} align value\n * @param {Object} node instance\n * @return {Object} node instance\n */\nconst setAlign = attr => value =>\n  R.tap(node => {\n    const yogaNode = node._yogaNode;\n\n    if (yogaNode) {\n      const yogaValue = R.cond([\n        [R.equals('flex-start'), R.always(Yoga.ALIGN_FLEX_START)],\n        [R.equals('center'), R.always(Yoga.ALIGN_CENTER)],\n        [R.equals('flex-end'), R.always(Yoga.ALIGN_FLEX_END)],\n        [R.equals('stretch'), R.always(Yoga.ALIGN_STRETCH)],\n        [R.equals('baseline'), R.always(Yoga.ALIGN_BASELINE)],\n        [R.equals('space-between'), R.always(Yoga.ALIGN_SPACE_BETWEEN)],\n        [R.equals('space-around'), R.always(Yoga.ALIGN_SPACE_AROUND)],\n        [R.T, R.always(Yoga.ALIGN_AUTO)],\n      ])(value);\n\n      yogaNode[`setAlign${upperFirst(attr)}`](yogaValue);\n    }\n  });\n\nexport default setAlign;\n","import setAlign from './setAlign';\n\n/**\n * Set align self attribute to node's Yoga instance\n *\n * @param {String} align value\n * @param {Object} node instance\n * @return {Object} node instance\n */\nconst setAlignSelf = setAlign('self');\n\nexport default setAlignSelf;\n","import * as R from 'ramda';\n\nimport setYogaValue from './setYogaValue';\n\n/**\n * Set flex shrink attribute to node's Yoga instance\n *\n * @param {Number} flex shrink value\n * @param {Object} node instance\n * @return {Object} node instance\n */\nconst setFlexShrink = R.compose(\n  setYogaValue('flexShrink'),\n  R.defaultTo(1),\n);\n\nexport default setFlexShrink;\n","import * as R from 'ramda';\n\n/**\n * Set aspect ratio attribute to node's Yoga instance\n *\n * @param {Number} ratio\n * @param {Object} node instance\n * @return {Object} node instance\n */\nconst setAspectRatio = value =>\n  R.tap(node => {\n    const yogaNode = node._yogaNode;\n\n    if (!R.isNil(value) && yogaNode) {\n      yogaNode.setAspectRatio(value);\n    }\n  });\n\nexport default setAspectRatio;\n","import setAlign from './setAlign';\n\n/**\n * Set align content attribute to node's Yoga instance\n *\n * @param {String} align value\n * @param {Object} node instance\n * @return {Object} node instance\n */\nconst setAlignContent = setAlign('content');\n\nexport default setAlignContent;\n","import * as R from 'ramda';\nimport Yoga from 'yoga-layout';\n\n/**\n * Set position type attribute to node's Yoga instance\n *\n * @param {String} position type\n * @param {Object} node instance\n * @return {Object} node instance\n */\nconst setPositionType = value =>\n  R.tap(node => {\n    const yogaNode = node._yogaNode;\n\n    if (!R.isNil(value) && yogaNode) {\n      yogaNode.setPositionType(\n        value === 'absolute'\n          ? Yoga.POSITION_TYPE_ABSOLUTE\n          : Yoga.POSITION_TYPE_RELATIVE,\n      );\n    }\n  });\n\nexport default setPositionType;\n","import * as R from 'ramda';\nimport Yoga from 'yoga-layout';\n\nconst isRow = R.equals('row');\nconst isRowReverse = R.equals('row-reverse');\nconst isColumnReverse = R.equals('column-reverse');\n\n/**\n * Set flex direction attribute to node's Yoga instance\n *\n * @param {String} flex direction value\n * @param {Object} node instance\n * @return {Object} node instance\n */\nconst setFlexDirection = value =>\n  R.tap(node => {\n    const yogaNode = node._yogaNode;\n\n    if (yogaNode) {\n      const yogaValue = R.cond([\n        [isRow, R.always(Yoga.FLEX_DIRECTION_ROW)],\n        [isRowReverse, R.always(Yoga.FLEX_DIRECTION_ROW_REVERSE)],\n        [isColumnReverse, R.always(Yoga.FLEX_DIRECTION_COLUMN_REVERSE)],\n        [R.T, R.always(Yoga.FLEX_DIRECTION_COLUMN)],\n      ])(value);\n\n      yogaNode.setFlexDirection(yogaValue);\n    }\n  });\n\nexport default setFlexDirection;\n","import * as R from 'ramda';\nimport Yoga from 'yoga-layout';\n\n/**\n * Set justify content attribute to node's Yoga instance\n *\n * @param {String} justify content value\n * @param {Object} node instance\n * @return {Object} node instance\n */\nconst setJustifyContent = value =>\n  R.tap(node => {\n    const yogaNode = node._yogaNode;\n\n    if (!R.isNil(value) && yogaNode) {\n      const yogaValue = R.cond([\n        [R.equals('center'), R.always(Yoga.JUSTIFY_CENTER)],\n        [R.equals('flex-end'), R.always(Yoga.JUSTIFY_FLEX_END)],\n        [R.equals('space-between'), R.always(Yoga.JUSTIFY_SPACE_BETWEEN)],\n        [R.equals('space-around'), R.always(Yoga.JUSTIFY_SPACE_AROUND)],\n        [R.equals('space-evenly'), R.always(Yoga.JUSTIFY_SPACE_EVENLY)],\n        [R.T, R.always(Yoga.JUSTIFY_FLEX_START)],\n      ])(value);\n\n      yogaNode.setJustifyContent(yogaValue);\n    }\n  });\n\nexport default setJustifyContent;\n","import * as R from 'ramda';\nimport Yoga from 'yoga-layout';\n\nimport setYogaValue from './setYogaValue';\n\n/**\n * Set margin top attribute to node's Yoga instance\n *\n * @param {Number} margin top\n * @param {Object} node instance\n * @return {Object} node instance\n */\nexport const setMarginTop = setYogaValue('margin', Yoga.EDGE_TOP);\n\n/**\n * Set margin right attribute to node's Yoga instance\n *\n * @param {Number} margin right\n * @param {Object} node instance\n * @return {Object} node instance\n */\nexport const setMarginRight = setYogaValue('margin', Yoga.EDGE_RIGHT);\n\n/**\n * Set margin bottom attribute to node's Yoga instance\n *\n * @param {Number} margin bottom\n * @param {Object} node instance\n * @return {Object} node instance\n */\nexport const setMarginBottom = setYogaValue('margin', Yoga.EDGE_BOTTOM);\n\n/**\n * Set margin left attribute to node's Yoga instance\n *\n * @param {Number} margin left\n * @param {Object} node instance\n * @return {Object} node instance\n */\nexport const setMarginLeft = setYogaValue('margin', Yoga.EDGE_LEFT);\n\n/**\n * Set all margins at once\n *\n * @param {Number} margin\n * @param {Object} node instance\n * @return {Object} node instance\n */\nexport const setMargin = margin =>\n  R.tap(node => {\n    setMarginTop(margin)(node);\n    setMarginRight(margin)(node);\n    setMarginBottom(margin)(node);\n    setMarginLeft(margin)(node);\n  });\n\nexport default setMargin;\n","import * as R from 'ramda';\nimport Yoga from 'yoga-layout';\n\nimport setYogaValue from './setYogaValue';\n\n/**\n * Set padding top attribute to node's Yoga instance\n *\n * @param {Number} padding top\n * @param {Object} node instance\n * @return {Object} node instance\n */\nexport const setPaddingTop = setYogaValue('padding', Yoga.EDGE_TOP);\n\n/**\n * Set padding right attribute to node's Yoga instance\n *\n * @param {Number} padding right\n * @param {Object} node instance\n * @return {Object} node instance\n */\nexport const setPaddingRight = setYogaValue('padding', Yoga.EDGE_RIGHT);\n\n/**\n * Set padding bottom attribute to node's Yoga instance\n *\n * @param {Number} padding bottom\n * @param {Object} node instance\n * @return {Object} node instance\n */\nexport const setPaddingBottom = setYogaValue('padding', Yoga.EDGE_BOTTOM);\n\n/**\n * Set padding left attribute to node's Yoga instance\n *\n * @param {Number} padding left\n * @param {Object} node instance\n * @return {Object} node instance\n */\nexport const setPaddingLeft = setYogaValue('padding', Yoga.EDGE_LEFT);\n\n/**\n * Set all paddings at once\n *\n * @param {Number} margin\n * @param {Object} node instance\n * @return {Object} node instance\n */\nexport const setPadding = padding =>\n  R.tap(node => {\n    setPaddingTop(padding)(node);\n    setPaddingRight(padding)(node);\n    setPaddingBottom(padding)(node);\n    setPaddingLeft(padding)(node);\n  });\n\nexport default setPadding;\n","import * as R from 'ramda';\nimport Yoga from 'yoga-layout';\n\nimport setYogaValue from './setYogaValue';\n\n/**\n * Set border top attribute to node's Yoga instance\n *\n * @param {Number} border top width\n * @param {Object} node instance\n * @return {Object} node instance\n */\nexport const setBorderTop = setYogaValue('border', Yoga.EDGE_TOP);\n\n/**\n * Set border right attribute to node's Yoga instance\n *\n * @param {Number} border right width\n * @param {Object} node instance\n * @return {Object} node instance\n */\nexport const setBorderRight = setYogaValue('border', Yoga.EDGE_RIGHT);\n\n/**\n * Set border bottom attribute to node's Yoga instance\n *\n * @param {Number} border bottom width\n * @param {Object} node instance\n * @return {Object} node instance\n */\nexport const setBorderBottom = setYogaValue('border', Yoga.EDGE_BOTTOM);\n\n/**\n * Set border left attribute to node's Yoga instance\n *\n * @param {Number} border left width\n * @param {Object} node instance\n * @return {Object} node instance\n */\nexport const setBorderLeft = setYogaValue('border', Yoga.EDGE_LEFT);\n\n/**\n * Set all border widths at once\n *\n * @param {Number} border width\n * @param {Object} node instance\n * @return {Object} node instance\n */\nexport const setBorder = width =>\n  R.tap(node => {\n    setBorderTop(width)(node);\n    setBorderRight(width)(node);\n    setBorderBottom(width)(node);\n    setBorderLeft(width)(node);\n  });\n\nexport default setBorder;\n","import * as R from 'ramda';\nimport Yoga from 'yoga-layout';\n\nimport setYogaValue from './setYogaValue';\n\n/**\n * Set position top attribute to node's Yoga instance\n *\n * @param {Number} position top\n * @param {Object} node instance\n * @return {Object} node instance\n */\nexport const setPositionTop = setYogaValue('position', Yoga.EDGE_TOP);\n\n/**\n * Set position right attribute to node's Yoga instance\n *\n * @param {Number} position right\n * @param {Object} node instance\n * @return {Object} node instance\n */\nexport const setPositionRight = setYogaValue('position', Yoga.EDGE_RIGHT);\n\n/**\n * Set position bottom attribute to node's Yoga instance\n *\n * @param {Number} position bottom\n * @param {Object} node instance\n * @return {Object} node instance\n */\nexport const setPositionBottom = setYogaValue('position', Yoga.EDGE_BOTTOM);\n\n/**\n * Set position left attribute to node's Yoga instance\n *\n * @param {Number} position left\n * @param {Object} node instance\n * @return {Object} node instance\n */\nexport const setPositionLeft = setYogaValue('position', Yoga.EDGE_LEFT);\n\n/**\n * Set all positions at once\n *\n * @param {Number} position\n * @param {Object} node instance\n * @return {Object} node instance\n */\nexport const setPosition = position =>\n  R.tap(node => {\n    setPositionTop(position)(node);\n    setPositionRight(position)(node);\n    setPositionBottom(position)(node);\n    setPositionLeft(position)(node);\n  });\n\nexport default setPosition;\n","import setYogaValue from './setYogaValue';\n\n/**\n * Set width to node's Yoga instance\n *\n * @param {Number} width\n * @param {Object} node instance\n * @return {Object} node instance\n */\nexport const setWidth = setYogaValue('width');\n\n/**\n * Set min width to node's Yoga instance\n *\n * @param {Number} min width\n * @param {Object} node instance\n * @return {Object} node instance\n */\nexport const setMinWidth = setYogaValue('minWidth');\n\n/**\n * Set max width to node's Yoga instance\n *\n * @param {Number} max width\n * @param {Object} node instance\n * @return {Object} node instance\n */\nexport const setMaxWidth = setYogaValue('maxWidth');\n\n/**\n * Set height to node's Yoga instance\n *\n * @param {Number} height\n * @param {Object} node instance\n * @return {Object} node instance\n */\nexport const setHeight = setYogaValue('height');\n\n/**\n * Set min height to node's Yoga instance\n *\n * @param {Number} min height\n * @param {Object} node instance\n * @return {Object} node instance\n */\nexport const setMinHeight = setYogaValue('minHeight');\n\n/**\n * Set max height to node's Yoga instance\n *\n * @param {Number} max height\n * @param {Object} node instance\n * @return {Object} node instance\n */\nexport const setMaxHeight = setYogaValue('maxHeight');\n","import * as R from 'ramda';\n\nimport { TEXT } from '../constants';\n\n/**\n * Checks if node is text\n *\n * @param {Object} node\n * @returns {Boolean} is node text?\n */\nconst isText = R.propEq('type', TEXT);\n\nexport default isText;\n","import * as R from 'ramda';\n\nimport { NOTE } from '../constants';\n\n/**\n * Checks if node is note\n *\n * @param {Object} node\n * @returns {Boolean} is node note?\n */\nconst isNote = R.propEq('type', NOTE);\n\nexport default isNote;\n","import * as R from 'ramda';\n\nimport { PAGE } from '../constants';\n\n/**\n * Checks if node is page\n *\n * @param {Object} node\n * @returns {Boolean} is node page?\n */\nconst isPage = R.propEq('type', PAGE);\n\nexport default isPage;\n","import * as R from 'ramda';\n\nimport { CANVAS } from '../constants';\n\n/**\n * Checks if node is canvas\n *\n * @param {Object} node\n * @returns {Boolean} is node canvas?\n */\nconst isCanvas = R.propEq('type', CANVAS);\n\nexport default isCanvas;\n","import { PDFFont } from '@react-pdf/pdfkit';\n\nclass StandardFont {\n  constructor(src) {\n    this.name = src;\n    this.src = PDFFont.open(null, src);\n  }\n\n  layout(str) {\n    const [encoded, positions] = this.src.encode(str);\n\n    return {\n      positions,\n      stringIndices: positions.map((_, i) => i),\n      glyphs: encoded.map((g, i) => {\n        const glyph = this.getGlyph(parseInt(g, 16));\n        glyph.advanceWidth = positions[i].advanceWidth;\n        return glyph;\n      }),\n    };\n  }\n\n  glyphForCodePoint(codePoint) {\n    const glyph = this.getGlyph(codePoint);\n    glyph.advanceWidth = 400;\n    return glyph;\n  }\n\n  getGlyph(id) {\n    return {\n      id,\n      _font: this.src,\n      codePoints: [id],\n      isLigature: false,\n      name: this.src.font.characterToGlyph(id),\n    };\n  }\n\n  hasGlyphForCodePoint(codePoint) {\n    return this.src.font.characterToGlyph(codePoint) !== '.notdef';\n  }\n\n  // Based on empirical observation\n  get ascent() {\n    return 900;\n  }\n\n  // Based on empirical observation\n  get descent() {\n    switch (this.name) {\n      case 'Times-Roman':\n      case 'Times-Bold':\n      case 'Times-Italic':\n        return -220;\n      case 'Courier':\n      case 'Courier-Bold':\n      case 'Courier-Oblique':\n        return -230;\n      default:\n        return -200;\n    }\n  }\n\n  get lineGap() {\n    return 0;\n  }\n\n  get unitsPerEm() {\n    return 1000;\n  }\n}\n\nexport default StandardFont;\n","import * as R from 'ramda';\n\nimport StandardFont from './standardFont';\n\nconst fontCache = {};\n\nconst IGNORED_CODE_POINTS = [173];\n\nconst getFontSize = R.pathOr(12, ['attributes', 'fontSize']);\n\nconst getOrCreateFont = name => {\n  if (fontCache[name]) return fontCache[name];\n\n  const font = new StandardFont(name);\n  fontCache[name] = font;\n\n  return font;\n};\n\nconst getFallbackFont = () => getOrCreateFont('Helvetica');\n\nconst shouldFallbackToFont = (codePoint, font) =>\n  !IGNORED_CODE_POINTS.includes(codePoint) &&\n  !font.hasGlyphForCodePoint(codePoint) &&\n  getFallbackFont().hasGlyphForCodePoint(codePoint);\n\nconst fontSubstitution = () => ({ string, runs }) => {\n  let lastFont = null;\n  let lastIndex = 0;\n  let index = 0;\n\n  const res = [];\n\n  for (const run of runs) {\n    const fontSize = getFontSize(run);\n    const defaultFont =\n      typeof run.attributes.font === 'string'\n        ? getOrCreateFont(run.attributes.font)\n        : run.attributes.font;\n\n    if (string.length === 0) {\n      res.push({ start: 0, end: 0, attributes: { font: defaultFont } });\n      break;\n    }\n\n    for (const char of string.slice(run.start, run.end)) {\n      const codePoint = char.codePointAt();\n      const shouldFallback = shouldFallbackToFont(codePoint, defaultFont);\n      const font = shouldFallback ? getFallbackFont() : defaultFont;\n\n      // If the default font does not have a glyph and the fallback font does, we use it\n      if (font !== lastFont) {\n        if (lastFont) {\n          res.push({\n            start: lastIndex,\n            end: index,\n            attributes: {\n              font: lastFont,\n              scale: lastFont ? fontSize / lastFont.unitsPerEm : 0,\n            },\n          });\n        }\n\n        lastFont = font;\n        lastIndex = index;\n      }\n\n      index += char.length;\n    }\n  }\n\n  if (lastIndex < string.length) {\n    const fontSize = getFontSize(R.last(runs));\n\n    res.push({\n      start: lastIndex,\n      end: string.length,\n      attributes: {\n        font: lastFont,\n        scale: lastFont ? fontSize / lastFont.unitsPerEm : 0,\n      },\n    });\n  }\n\n  return { string, runs: res };\n};\n\nexport default fontSubstitution;\n","/**\n * Capitalize first letter of each word\n *\n * @param {String} string\n * @returns {String} capitalized string\n */\nconst capitalize = value => {\n  if (!value) return value;\n  return value.replace(/(^|\\s)\\S/g, l => l.toUpperCase());\n};\n\nexport default capitalize;\n","const IGNORABLE_CODEPOINTS = [\n  8232, // LINE_SEPARATOR\n  8233, // PARAGRAPH_SEPARATOR\n];\n\nconst buildSubsetForFont = font =>\n  IGNORABLE_CODEPOINTS.reduce((acc, codePoint) => {\n    if (font.hasGlyphForCodePoint && font.hasGlyphForCodePoint(codePoint)) {\n      return acc;\n    }\n    return [...acc, String.fromCharCode(codePoint)];\n  }, []);\n\nexport const ignoreChars = fragments =>\n  fragments.map(fragment => {\n    const charSubset = buildSubsetForFont(fragment.attributes.font);\n    const subsetRegex = new RegExp(charSubset.join('|'));\n\n    return {\n      string: fragment.string.replace(subsetRegex, ''),\n      attributes: fragment.attributes,\n    };\n  });\n","import * as R from 'ramda';\n\nimport { TEXT_INSTANCE } from '../constants';\n\n/**\n * Checks if node is text intance\n *\n * @param {Object} node\n * @returns {Boolean} is node text intance?\n */\nconst isTextInstance = R.propEq('type', TEXT_INSTANCE);\n\nexport default isTextInstance;\n","import AttributedString from '@react-pdf/textkit/attributedString';\n\nimport Font from '../font';\nimport isImage from '../node/isImage';\nimport { embedEmojis } from './emoji';\nimport capitalize from '../utils/capitalize';\nimport upperFirst from '../utils/upperFirst';\nimport { ignoreChars } from './ignorableChars';\nimport isTextInstance from '../node/isTextInstance';\n\nconst PREPROCESSORS = [ignoreChars, embedEmojis];\n\n/**\n * Apply transformation to text string\n *\n * @param {String} text\n * @param {String} transformation type\n * @returns {String} transformed text\n */\nconst transformText = (text, transformation) => {\n  switch (transformation) {\n    case 'uppercase':\n      return text.toUpperCase();\n    case 'lowercase':\n      return text.toLowerCase();\n    case 'capitalize':\n      return capitalize(text);\n    case 'upperfirst':\n      return upperFirst(text);\n    default:\n      return text;\n  }\n};\n\n/**\n * Get textkit framgents of given node object\n *\n * @param {Object} instance node\n * @returns {Array} text fragments\n */\nconst getFragments = instance => {\n  if (!instance) return [{ string: '' }];\n\n  let fragments = [];\n  const {\n    color = 'black',\n    backgroundColor,\n    fontFamily = 'Helvetica',\n    fontWeight,\n    fontStyle,\n    fontSize = 18,\n    textAlign = 'left',\n    lineHeight,\n    textDecoration,\n    textDecorationColor,\n    textDecorationStyle,\n    textTransform,\n    letterSpacing,\n    textIndent,\n    opacity,\n  } = instance.style;\n\n  const obj = Font.getFont({ fontFamily, fontWeight, fontStyle });\n  const font = obj ? obj.data : fontFamily;\n\n  const attributes = {\n    font,\n    color,\n    opacity,\n    fontSize,\n    backgroundColor,\n    align: textAlign,\n    indent: textIndent,\n    link: instance.src,\n    characterSpacing: letterSpacing,\n    underlineStyle: textDecorationStyle,\n    underline: textDecoration === 'underline',\n    underlineColor: textDecorationColor || color,\n    strike: textDecoration === 'line-through',\n    strikeStyle: textDecorationStyle,\n    strikeColor: textDecorationColor || color,\n    lineHeight: lineHeight ? lineHeight * fontSize : null,\n  };\n\n  instance.children.forEach(child => {\n    if (isImage(child)) {\n      fragments.push({\n        string: String.fromCharCode(0xfffc),\n        attributes: {\n          ...attributes,\n          attachment: {\n            width: child.style.width || fontSize,\n            height: child.style.height || fontSize,\n            image: child.image.data,\n          },\n        },\n      });\n    } else if (isTextInstance(child)) {\n      fragments.push({\n        string: transformText(child.value, textTransform),\n        attributes,\n      });\n    } else {\n      if (child) {\n        fragments.push(...getFragments(child));\n      }\n    }\n  });\n\n  for (const preprocessor of PREPROCESSORS) {\n    fragments = preprocessor(fragments);\n  }\n\n  return fragments;\n};\n\n/**\n * Get textkit attributed string from text node\n *\n * @param {Object} instance node\n * @returns {Object} attributed string\n */\nconst getAttributedString = instance =>\n  AttributedString.fromFragments(getFragments(instance));\n\nexport default getAttributedString;\n","import * as R from 'ramda';\nimport layoutEngine from '@react-pdf/textkit/layout';\nimport linebreaker from '@react-pdf/textkit/engines/linebreaker';\nimport justification from '@react-pdf/textkit/engines/justification';\nimport textDecoration from '@react-pdf/textkit/engines/textDecoration';\nimport scriptItemizer from '@react-pdf/textkit/engines/scriptItemizer';\nimport wordHyphenation from '@react-pdf/textkit/engines/wordHyphenation';\n\nimport Font from '../font';\nimport fontSubstitution from './fontSubstitution';\nimport getAttributedString from './getAttributedString';\n\nconst engines = {\n  linebreaker,\n  justification,\n  textDecoration,\n  scriptItemizer,\n  wordHyphenation,\n  fontSubstitution,\n};\n\nconst engine = layoutEngine(engines);\n\n/**\n * Get layout container for specific text node\n *\n * @param {Object} node\n * @param {Number} width\n * @param {Number} height\n * @returns {Object} layout container\n */\nconst getContainer = (node, width, height) => {\n  const maxLines = R.path(['style', 'maxLines'], node);\n  const textOverflow = R.path(['style', 'textOverflow'], node);\n\n  return {\n    x: 0,\n    y: 0,\n    width,\n    maxLines,\n    height: height || Infinity,\n    truncateMode: textOverflow,\n  };\n};\n\n/**\n * Get text layout options for specific text node\n *\n * @param {Object} node instance\n * @returns {Object} layout options\n */\nconst getLayoutOptions = node => ({\n  hyphenationPenalty: node.props.hyphenationPenalty,\n  hyphenationCallback: Font.getHyphenationCallback(),\n  shrinkWhitespaceFactor: { before: -0.5, after: -0.5 },\n});\n\n/**\n * Get text lines for given node\n *\n * @param {Object} node\n * @param {Number} container width\n * @param {Number} container height\n * @returns {Array} layout lines\n */\nconst layoutText = R.compose(\n  R.reduce(R.concat, []),\n  R.converge(engine, [getAttributedString, getContainer, getLayoutOptions]),\n);\n\n// TODO: Do it memoizable?\nexport default layoutText;\n","import AttributedString from '@react-pdf/textkit/attributedString';\n\n/**\n * Get lines width (if any)\n *\n * @param {Object} node\n * @returns {Number} lines width\n */\nconst linesWidth = node => {\n  if (!node.lines) return -1;\n  return Math.max(\n    ...node.lines.map(line => AttributedString.advanceWidth(line)),\n  );\n};\n\nexport default linesWidth;\n","/**\n * Get lines height (if any)\n *\n * @param {Object} node\n * @returns {Number} lines height\n */\nconst linesHeight = node => {\n  if (!node.lines) return -1;\n  return node.lines.reduce((acc, line) => acc + line.box.height, 0);\n};\n\nexport default linesHeight;\n","import * as R from 'ramda';\nimport Yoga from 'yoga-layout';\n\nimport layoutText from './layoutText';\nimport linesWidth from './linesWidth';\nimport linesHeight from './linesHeight';\n\n/**\n * Yoga text measure function\n *\n * @param {Object} page\n * @param {Object} node\n * @param {Number} width\n * @param {Number} widthMode\n * @param {Number} height\n * @param {Number} heightMode\n * @returns {Object} text width and height\n */\nconst measureText = (page, node, width, widthMode, height, heightMode) => {\n  if (widthMode === Yoga.MEASURE_MODE_EXACTLY) {\n    if (!node.lines) node.lines = layoutText(node, width, height);\n\n    return { height: linesHeight(node) };\n  }\n\n  if (widthMode === Yoga.MEASURE_MODE_AT_MOST) {\n    if (!node.lines) node.lines = layoutText(node, width, height);\n\n    return {\n      height: linesHeight(node),\n      width: Math.min(width, linesWidth(node)),\n    };\n  }\n\n  return {};\n};\n\nexport default R.curryN(6, measureText);\n","import * as R from 'ramda';\n\n/**\n * Get image ratio\n *\n * @param {Object} image node\n * @returns {Number} image ratio\n */\nconst getRatio = R.ifElse(\n  R.hasPath(['image', 'data']),\n  node => node.image.width / node.image.height,\n  R.always(1),\n);\n\nexport default getRatio;\n","import * as R from 'ramda';\n\n/**\n * Checks if page has auto height\n *\n * @param {Object} page\n * @returns {Boolean} is page height auto\n */\nconst isHeightAuto = R.pathSatisfies(R.isNil, ['box', 'height']);\n\nexport default isHeightAuto;\n","import * as R from 'ramda';\nimport Yoga from 'yoga-layout';\n\nimport getRatio from '../image/getRatio';\nimport getMargin from '../node/getMargin';\nimport getPadding from '../node/getPadding';\nimport isHeightAuto from '../page/isHeightAuto';\n\nconst SAFETY_HEIGHT = 10;\n\n/**\n * Yoga image measure function\n *\n * @param {Object} page\n * @param {Object} node\n * @param {Number} width\n * @param {Number} widthMode\n * @param {Number} height\n * @param {Number} heightMode\n * @returns {Object} image width and height\n */\nconst measureImage = (page, node, width, widthMode, height, heightMode) => {\n  const imageRatio = getRatio(node);\n  const imageMargin = getMargin(node);\n  const pagePadding = getPadding(page);\n  const pageArea = isHeightAuto(page)\n    ? Infinity\n    : page.box.height -\n      pagePadding.paddingTop -\n      pagePadding.paddingBottom -\n      imageMargin.marginTop -\n      imageMargin.marginBottom -\n      SAFETY_HEIGHT;\n\n  // Skip measure if image data not present yet\n  if (!node.image) return { width: 0, height: 0 };\n\n  if (\n    widthMode === Yoga.MEASURE_MODE_EXACTLY &&\n    heightMode === Yoga.MEASURE_MODE_UNDEFINED\n  ) {\n    const scaledHeight = width / imageRatio;\n    return { height: Math.min(pageArea, scaledHeight) };\n  }\n\n  if (\n    heightMode === Yoga.MEASURE_MODE_EXACTLY &&\n    (widthMode === Yoga.MEASURE_MODE_AT_MOST ||\n      widthMode === Yoga.MEASURE_MODE_UNDEFINED)\n  ) {\n    return { width: Math.min(height * imageRatio, width) };\n  }\n\n  if (\n    widthMode === Yoga.MEASURE_MODE_EXACTLY &&\n    heightMode === Yoga.MEASURE_MODE_AT_MOST\n  ) {\n    const scaledHeight = width / imageRatio;\n    return { height: Math.min(height, pageArea, scaledHeight) };\n  }\n\n  if (\n    widthMode === Yoga.MEASURE_MODE_AT_MOST &&\n    heightMode === Yoga.MEASURE_MODE_AT_MOST\n  ) {\n    if (imageRatio > 1) {\n      return {\n        width: width,\n        height: Math.min(width / imageRatio, height),\n      };\n    } else {\n      return {\n        width: Math.min(height * imageRatio, width),\n        height: height,\n      };\n    }\n  }\n\n  return { height, width };\n};\n\nexport default R.curryN(6, measureImage);\n","import * as R from 'ramda';\n\nimport getMargin from '../node/getMargin';\nimport getPadding from '../node/getPadding';\nimport isHeightAuto from '../page/isHeightAuto';\n\nconst SAFETY_HEIGHT = 10;\n\nconst getMax = R.reduce(R.max, -Infinity);\n\n/**\n * Helper object to predict canvas size\n * TODO: Implement remaining functions (as close as possible);\n */\nconst measureCtx = () => {\n  const ctx = {};\n  const points = [];\n\n  const nil = () => ctx;\n  const addPoint = (x, y) => points.push([x, y]);\n  const moveTo = R.compose(\n    nil,\n    addPoint,\n  );\n\n  const rect = (x, y, w, h) => {\n    addPoint(x, y);\n    addPoint(x + w, y);\n    addPoint(x, y + h);\n    addPoint(x + w, y + h);\n    return ctx;\n  };\n\n  const ellipse = (x, y, rx, ry) => {\n    ry = ry || rx;\n\n    addPoint(x - rx, y - ry);\n    addPoint(x + rx, y - ry);\n    addPoint(x + rx, y + ry);\n    addPoint(x - rx, y + ry);\n\n    return ctx;\n  };\n\n  const polygon = (...pts) => {\n    points.push(...pts);\n    return nil();\n  };\n\n  // Change dimensions\n  ctx.rect = rect;\n  ctx.moveTo = moveTo;\n  ctx.lineTo = moveTo;\n  ctx.circle = ellipse;\n  ctx.polygon = polygon;\n  ctx.ellipse = ellipse;\n  ctx.roundedRect = rect;\n\n  // To be implemented\n  ctx.text = nil;\n  ctx.path = nil;\n  ctx.lineWidth = nil;\n  ctx.bezierCurveTo = nil;\n  ctx.quadraticCurveTo = nil;\n\n  ctx.scale = nil;\n  ctx.rotate = nil;\n  ctx.translate = nil;\n\n  // These don't really change dimensions\n  ctx.dash = nil;\n  ctx.clip = nil;\n  ctx.save = nil;\n  ctx.fill = nil;\n  ctx.font = nil;\n  ctx.stroke = nil;\n  ctx.lineCap = nil;\n  ctx.opacity = nil;\n  ctx.restore = nil;\n  ctx.lineJoin = nil;\n  ctx.fontSize = nil;\n  ctx.fillColor = nil;\n  ctx.miterLimit = nil;\n  ctx.strokeColor = nil;\n  ctx.fillOpacity = nil;\n  ctx.strokeOpacity = nil;\n  ctx.linearGradient = nil;\n  ctx.radialGradient = nil;\n\n  ctx.getWidth = () =>\n    R.compose(\n      getMax,\n      R.pluck(0),\n    )(points);\n\n  ctx.getHeight = () =>\n    R.compose(\n      getMax,\n      R.pluck(1),\n    )(points);\n\n  return ctx;\n};\n\n/**\n * Yoga canbas measure function\n *\n * @param {Object} page\n * @param {Object} node\n * @param {Number} width\n * @param {Number} widthMode\n * @param {Number} height\n * @param {Number} heightMode\n * @returns {Object} canvas width and height\n */\nconst measureCanvas = (page, node) => {\n  const imageMargin = getMargin(node);\n  const pagePadding = getPadding(page);\n  const pageArea = isHeightAuto(page)\n    ? Infinity\n    : page.box.height -\n      pagePadding.paddingTop -\n      pagePadding.paddingBottom -\n      imageMargin.marginTop -\n      imageMargin.marginBottom -\n      SAFETY_HEIGHT;\n\n  const ctx = measureCtx();\n\n  node.props.paint(ctx);\n\n  const width = ctx.getWidth();\n  const height = Math.min(pageArea, ctx.getHeight());\n\n  return { height, width };\n};\n\nexport default R.curryN(6, measureCanvas);\n","import * as R from 'ramda';\nimport Yoga from 'yoga-layout';\n\nimport getMargin from '../node/getMargin';\nimport getPadding from '../node/getPadding';\nimport getPosition from '../node/getPosition';\nimport getDimension from '../node/getDimension';\nimport getBorderWidth from '../node/getBorderWidth';\nimport setFlex from '../node/setFlex';\nimport setDisplay from '../node/setDisplay';\nimport setOverflow from '../node/setOverflow';\nimport setFlexWrap from '../node/setFlexWrap';\nimport setFlexGrow from '../node/setFlexGrow';\nimport setFlexBasis from '../node/setFlexBasis';\nimport setAlignSelf from '../node/setAlignSelf';\nimport setFlexShrink from '../node/setFlexShrink';\nimport setAspectRatio from '../node/setAspectRatio';\nimport setAlignContent from '../node/setAlignContent';\nimport setPositionType from '../node/setPositionType';\nimport setFlexDirection from '../node/setFlexDirection';\nimport setJustifyContent from '../node/setJustifyContent';\nimport {\n  setMarginTop,\n  setMarginRight,\n  setMarginBottom,\n  setMarginLeft,\n} from '../node/setMargin';\nimport {\n  setPaddingTop,\n  setPaddingRight,\n  setPaddingBottom,\n  setPaddingLeft,\n} from '../node/setPadding';\nimport {\n  setBorderTop,\n  setBorderRight,\n  setBorderBottom,\n  setBorderLeft,\n} from '../node/setBorderWidth';\nimport {\n  setPositionTop,\n  setPositionRight,\n  setPositionBottom,\n  setPositionLeft,\n} from '../node/setPosition';\nimport {\n  setWidth,\n  setHeight,\n  setMinWidth,\n  setMaxWidth,\n  setMinHeight,\n  setMaxHeight,\n} from '../node/setDimension';\nimport isText from '../node/isText';\nimport isNote from '../node/isNote';\nimport isPage from '../node/isPage';\nimport isImage from '../node/isImage';\nimport isCanvas from '../node/isCanvas';\nimport measureText from '../text/measureText';\nimport measureImage from '../image/measureImage';\nimport measureCanvas from '../canvas/measureCanvas';\nimport isTextInstance from '../node/isTextInstance';\n\nconst YOGA_NODE = '_yogaNode';\nconst YOGA_CONFIG = Yoga.Config.create();\n\nYOGA_CONFIG.setPointScaleFactor(0);\n\nconst setNodeHeight = node =>\n  R.ifElse(\n    isPage,\n    setHeight(node.box.height),\n    setHeight(node.box.height || node.style.height),\n  );\n\n/**\n * Set styles valeus into yoga node before layout calculation\n *\n * @param {Object} node\n * @returns {Object} node\n */\nconst setYogaValues = R.tap(node => {\n  R.compose(\n    setNodeHeight(node),\n    setWidth(node.style.width),\n    setMinWidth(node.style.minWidth),\n    setMaxWidth(node.style.maxWidth),\n    setMinHeight(node.style.minHeight),\n    setMaxHeight(node.style.maxHeight),\n    setMarginTop(node.style.marginTop),\n    setMarginRight(node.style.marginRight),\n    setMarginBottom(node.style.marginBottom),\n    setMarginLeft(node.style.marginLeft),\n    setPaddingTop(node.style.paddingTop),\n    setPaddingRight(node.style.paddingRight),\n    setPaddingBottom(node.style.paddingBottom),\n    setPaddingLeft(node.style.paddingLeft),\n    setPositionType(node.style.position),\n    setPositionTop(node.style.top),\n    setPositionRight(node.style.right),\n    setPositionBottom(node.style.bottom),\n    setPositionLeft(node.style.left),\n    setBorderTop(node.style.borderTopWidth),\n    setBorderRight(node.style.borderRightWidth),\n    setBorderBottom(node.style.borderBottomWidth),\n    setBorderLeft(node.style.borderLeftWidth),\n    setDisplay(node.style.display),\n    setFlexDirection(node.style.flexDirection),\n    setAlignSelf(node.style.alignSelf),\n    setAlignContent(node.style.alignContent),\n    setJustifyContent(node.style.justifyContent),\n    setFlexWrap(node.style.flexWrap),\n    setOverflow(node.style.overflow),\n    setAspectRatio(node.style.aspectRatio),\n    setFlex(node.style.flex),\n    setFlexBasis(node.style.flexBasis),\n    setFlexGrow(node.style.flexGrow),\n    setFlexShrink(node.style.flexShrink),\n  )(node);\n});\n\n/**\n * Inserts child into parent' yoga node\n *\n * @param {Object} parent\n * @param {Object} node\n * @param {Object} node\n */\nconst insertYogaNodes = parent =>\n  R.tap(child => parent.insertChild(child[YOGA_NODE], parent.getChildCount()));\n\nconst setMeasureFunc = page => node => {\n  const yogaNode = node[YOGA_NODE];\n\n  if (isText(node)) {\n    yogaNode.setMeasureFunc(measureText(page, node));\n  }\n\n  if (isImage(node)) {\n    yogaNode.setMeasureFunc(measureImage(page, node));\n  }\n\n  if (isCanvas(node)) {\n    yogaNode.setMeasureFunc(measureCanvas(page, node));\n  }\n\n  return node;\n};\n\nconst isNotText = R.complement(isText);\nconst isNotNote = R.complement(isNote);\nconst isLayoutElement = R.both(isNotText, isNotNote);\nconst isNotTextInstance = R.complement(isTextInstance);\n\n/**\n * Creates and add yoga node to document tree\n * Handles measure function for text and image nodes\n *\n * @param {Object} node\n * @returns {Object} node with appended yoga node\n */\nconst createYogaNodes = page => node => {\n  const yogaNode = Yoga.Node.createWithConfig(YOGA_CONFIG);\n\n  return R.compose(\n    setMeasureFunc(page),\n    R.when(\n      isLayoutElement,\n      R.evolve({\n        children: R.map(\n          R.compose(\n            insertYogaNodes(yogaNode),\n            createYogaNodes(page),\n          ),\n        ),\n      }),\n    ),\n    setYogaValues,\n    R.assoc(YOGA_NODE, yogaNode),\n  )(node);\n};\n\n/**\n * Performs yoga calculation\n *\n * @param {Object} node\n * @returns {Object} node\n */\nconst calculateLayout = R.tap(page => page[YOGA_NODE].calculateLayout());\n\n/**\n * Saves Yoga layout result into 'box' attribute of node\n *\n * @param {Object} node\n * @returns {Object} node with box data\n */\nconst persistDimensions = node => {\n  return R.evolve({\n    children: R.map(R.when(isNotTextInstance, persistDimensions)),\n    box: R.always(\n      R.mergeAll([\n        getPadding(node),\n        getMargin(node),\n        getBorderWidth(node),\n        getPosition(node),\n        getDimension(node),\n      ]),\n    ),\n  })(node);\n};\n\n/**\n * Removes and destroys yoga node frm document tree\n *\n * @param {Object} node\n * @returns {Object} node without yoga node\n */\nconst destroyYogaNodes = node => {\n  return R.compose(\n    R.dissoc(YOGA_NODE),\n    R.tap(n => Yoga.Node.destroy(n[YOGA_NODE])),\n    R.evolve({ children: R.map(R.when(isLayoutElement, destroyYogaNodes)) }),\n  )(node);\n};\n\n/**\n * Calculates page object layout using Yoga.\n * Takes node values from 'box' and 'style' attributes, and persist them back into 'box'\n * Destroy yoga values at the end.\n *\n * @param {Object} page object\n * @returns {Object} page object with correct 'box' layout attributes\n */\nexport const resolvePageDimensions = page =>\n  R.ifElse(\n    R.isNil,\n    R.always(null),\n    R.compose(\n      destroyYogaNodes,\n      persistDimensions,\n      calculateLayout,\n      createYogaNodes(page),\n    ),\n  )(page);\n\n/**\n * Calculates root object layout using Yoga.\n *\n * @param {Object} root object\n * @returns {Object} root object with correct 'box' layout attributes\n */\nconst resolveDimensions = R.evolve({\n  children: R.map(\n    R.evolve({\n      children: R.map(resolvePageDimensions),\n    }),\n  ),\n});\n\nexport default resolveDimensions;\n","import * as R from 'ramda';\n\nimport isText from '../node/isText';\nimport layoutText from '../text/layoutText';\n\nconst shouldLayoutText = node => isText(node) && !node.lines;\n\n/**\n * Performs text layout on text node if wasn't calculated before.\n * Text layout is usually performed on Yoga's layout process (via setMeasureFunc),\n * but we need to layout those nodes with fixed width and height.\n *\n * @param {Object} node\n * @returns {Object} layouted node\n */\nconst resolveTextLayout = node =>\n  R.compose(\n    R.evolve({ children: R.map(resolveTextLayout) }),\n    R.when(\n      shouldLayoutText,\n      R.compose(\n        R.converge(R.assoc('lines'), [\n          R.converge(layoutText, [\n            R.identity,\n            R.path(['box', 'width']),\n            R.path(['box', 'height']),\n          ]),\n          R.identity,\n        ]),\n      ),\n    ),\n  )(node);\n\nexport default resolveTextLayout;\n","import * as R from 'ramda';\n\nimport { INHERITED_PROPERTIES } from '../constants';\n\n/**\n * Get styles sub group of inherited properties\n *\n * @param {Object} style object\n * @returns {Object} style object only with inherited properties\n */\nconst getInheritStyles = R.compose(\n  R.pick(INHERITED_PROPERTIES),\n  R.propOr({}, 'style'),\n);\n\n/**\n * Merges styles with node\n *\n * @param {Object} style object\n * @param {Object} node\n * @returns {Object} node with styles merged\n */\nconst mergeStyles = styles =>\n  R.evolve({\n    style: R.merge(styles),\n  });\n\n/**\n * Inherit style values from the root to the leafs\n *\n * @param {Object} document root\n * @returns {Object} document root with inheritance\n *\n */\nconst resolveInheritance = node => {\n  const inheritStyles = getInheritStyles(node);\n\n  return R.evolve({\n    children: R.map(\n      R.compose(\n        resolveInheritance,\n        mergeStyles(inheritStyles),\n      ),\n    ),\n  })(node);\n};\n\nexport default resolveInheritance;\n","import * as R from 'ramda';\n\nimport setMargin from './setMargin';\n\n/**\n * Removes margins on node\n *\n * @param {Object} node\n * @returns {Object} node without margins\n */\nconst removeMargins = R.compose(\n  setMargin(0),\n  R.dissocPath(['style', 'margin']),\n  R.dissocPath(['style', 'marginTop']),\n  R.dissocPath(['style', 'marginRight']),\n  R.dissocPath(['style', 'marginBottom']),\n  R.dissocPath(['style', 'marginLeft']),\n  R.dissocPath(['style', 'marginHorizontal']),\n  R.dissocPath(['style', 'marginVertical']),\n);\n\nexport default removeMargins;\n","import * as R from 'ramda';\n\nimport removeMargins from '../node/removeMargins';\n\n/**\n * Remove page margins\n *\n * @param {Object} document root\n * @returns {Object} documrnt root without margins on pages\n */\nconst resolvePageMargins = R.evolve({\n  children: R.map(\n    R.evolve({\n      children: R.map(removeMargins),\n    }),\n  ),\n});\n\nexport default resolvePageMargins;\n","import * as R from 'ramda';\n\n/**\n * Get many nodes height\n *\n * @param {Array} nodes\n * @return {number} nodes height\n */\nconst getNodesHeight = nodes => {\n  let max = 0;\n  let min = Infinity;\n\n  if (R.isEmpty(nodes)) return 0;\n\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    min = Math.min(min, node.box.top);\n    max = Math.max(max, node.box.top + node.box.height);\n  }\n\n  return max - min;\n};\n\nexport default getNodesHeight;\n","import * as R from 'ramda';\n\nimport isNote from './isNote';\nimport isImage from './isImage';\nimport isCanvas from './isCanvas';\nimport getNodesHeight from './getNodesHeight';\n\nconst getWrap = R.ifElse(\n  R.anyPass([isNote, isImage, isCanvas]),\n  R.always(false),\n  R.pathOr(true, ['props', 'wrap']),\n);\n\nconst getBreak = R.pathOr(false, ['props', 'break']);\n\nconst getMinPresenceAhead = R.path(['props', 'minPresenceAhead']);\n\nconst defaultPresenceAhead = element => height =>\n  Math.min(element.box.height, height);\n\nconst getPresenceAhead = (elements, height) => {\n  let result = 0;\n\n  for (let i = 0; i < elements.length; i++) {\n    const element = elements[i];\n\n    if (!element.box) continue;\n\n    const isElementInside = height > element.box.top;\n    const presenceAhead =\n      element.props.presenceAhead || defaultPresenceAhead(element);\n\n    if (element && isElementInside) {\n      result += presenceAhead(height - element.box.top);\n    }\n  }\n\n  return result;\n};\n\nconst shouldBreak = (child, futureElements, height) => {\n  const minPresenceAhead = getMinPresenceAhead(child);\n  const presenceAhead = getPresenceAhead(futureElements, height);\n  const futureHeight = getNodesHeight(futureElements);\n  const shouldSplit = height < child.box.top + child.box.height;\n  const shouldWrap = getWrap(child);\n\n  return (\n    getBreak(child) ||\n    (!shouldWrap && shouldSplit) ||\n    (minPresenceAhead < futureHeight && presenceAhead < minPresenceAhead)\n  );\n};\n\nexport default shouldBreak;\n","import * as R from 'ramda';\n\nconst getPaddingBottom = R.pathOr(0, ['style', 'paddingBottom']);\n\nconst getContentArea = page => {\n  const paddingBottom = getPaddingBottom(page);\n  const height = R.path(['style', 'height'], page);\n  return height - paddingBottom;\n};\n\nexport default getContentArea;\n","import * as R from 'ramda';\n\nimport shouldNodeBreak from '../node/shouldBreak';\nimport getContentArea from '../page/getContentArea';\nimport { resolvePageDimensions } from './resolveDimensions';\n\nconst getHeight = R.path(['box', 'height']);\n\nconst getTop = R.pathOr(0, ['box', 'top']);\n\nconst getChildren = R.propOr([], 'children');\n\nconst setChildren = R.assoc('children');\n\nconst setHeight = R.assocPath(['box', 'height']);\n\nconst setBreak = R.assocPath(['props', 'break']);\n\nconst breakChildren = (height, node) => {\n  const children = getChildren(node);\n\n  let offset = null;\n  let nextElements = [];\n  const currentElements = [];\n\n  for (let i = 0; i < children.length; i++) {\n    const child = children[i];\n    const childTop = getTop(child);\n    const childHeight = getHeight(child);\n    const futureElements = children.slice(i + 1);\n    const shouldBreak = shouldNodeBreak(child, futureElements, height);\n\n    if (shouldBreak) {\n      offset = childTop;\n      nextElements = R.compose(\n        R.prepend(setBreak(false, child)),\n        R.slice(i + 1, Infinity),\n      )(children);\n      break;\n    }\n\n    const [currentChildren, nextChildren, childsOffset] = breakChildren(\n      height,\n      child,\n    );\n\n    if (R.isNil(childsOffset)) {\n      currentElements.push(setChildren(currentChildren, child));\n      continue;\n    }\n\n    offset = childTop + childsOffset;\n\n    currentElements.push(\n      R.compose(\n        setChildren(currentChildren),\n        setHeight(Math.ceil(offset / height) * height - childTop),\n      )(child),\n    );\n\n    nextElements = R.compose(\n      R.prepend(\n        R.compose(\n          setChildren(nextChildren),\n          setHeight(child.box.height - childHeight),\n        )(child),\n      ),\n      R.slice(i + 1, Infinity),\n    )(children);\n\n    break;\n  }\n\n  return [currentElements, nextElements, offset];\n};\n\nconst breakNode = height => node => {\n  const [currentChildren, nextChildren, offset] = breakChildren(height, node);\n\n  if (R.isNil(offset)) return [node];\n\n  const currentNode = R.compose(\n    setChildren(currentChildren),\n    setHeight(Math.ceil(offset / height) * height),\n  )(node);\n\n  const nextNode = R.compose(\n    setChildren(nextChildren),\n    setHeight(node.box.height - offset),\n  )(node);\n\n  return [currentNode, nextNode];\n};\n\nconst breakPage = page => {\n  const pages = [];\n  const height = getContentArea(page);\n\n  let subpages = breakNode(height)(page);\n  let current = subpages[0];\n  let nextPage = subpages[1];\n\n  pages.push(current);\n\n  while (nextPage) {\n    subpages = R.compose(\n      breakNode(height),\n      resolvePageDimensions,\n      setHeight(null),\n    )(nextPage);\n\n    current = subpages[0];\n    nextPage = subpages[1];\n\n    pages.push(current);\n  }\n\n  return pages;\n};\n\nconst resolvePageBreaks = R.evolve({\n  children: R.map(\n    R.evolve({\n      children: R.compose(\n        R.flatten,\n        R.map(breakPage),\n      ),\n    }),\n  ),\n});\n\nexport default resolvePageBreaks;\n","import * as R from 'ramda';\n\nconst getTop = R.pathOr(0, ['box', 'top']);\n\nconst getHeight = R.path(['box', 'height']);\n\nconst getChildren = R.propOr([], 'children');\n\nconst isElementOutside = R.useWith(R.lte, [R.identity, getTop]);\n\nconst splitNodes = (height, nodes) => {\n  const currentChildren = [];\n  const nextChildren = [];\n\n  for (let i = 0; i < nodes.length; i++) {\n    const child = nodes[i];\n    const [currentChild, nextChild] = splitNode(height, child);\n\n    if (currentChild) currentChildren.push(currentChild);\n    if (nextChild) nextChildren.push(nextChild);\n  }\n\n  return [currentChildren, nextChildren];\n};\n\nconst splitChildren = (height, node) => {\n  const children = getChildren(node);\n  const availableHeight = height - getTop(node);\n  return splitNodes(availableHeight, children);\n};\n\nconst splitNode = R.curryN(2, (height, node) => {\n  if (!node) return [null, null];\n\n  const nodeTop = getTop(node);\n  const nodeHeight = getHeight(node);\n  const isOutside = isElementOutside(height, node);\n  const shouldSplit = height < nodeTop + nodeHeight;\n\n  if (isOutside) {\n    const next = R.evolve({ box: { top: R.subtract(R.__, height) } })(node);\n    return [null, next, false];\n  }\n\n  if (shouldSplit) {\n    const [currentChilds, nextChildren] = splitChildren(height, node);\n\n    const current = R.evolve({\n      children: R.always(currentChilds),\n      style: {\n        borderBottomLeftRadius: R.always(0),\n        borderBottomRightRadius: R.always(0),\n      },\n      box: {\n        height: R.when(R.always(shouldSplit), R.always(height - nodeTop)),\n      },\n    })(node);\n\n    const next = R.evolve({\n      children: R.always(nextChildren),\n      style: {\n        borderTopLeftRadius: R.always(0),\n        borderTopRightRadius: R.always(0),\n      },\n      box: {\n        top: R.always(0),\n        height: R.subtract(R.__, height - nodeTop),\n      },\n    })(node);\n\n    return [current, next];\n  }\n\n  return [node, null, false];\n});\n\nexport default splitNode;\n","import * as R from 'ramda';\n\nimport splitNode from '../node/split';\n\nconst getPaddingBottom = R.pathOr(0, ['style', 'paddingBottom']);\n\nconst getWrappingArea = page => {\n  const paddingBottom = getPaddingBottom(page);\n  const height = R.path(['style', 'height'], page);\n  return height - paddingBottom;\n};\n\nconst splitPage = page => {\n  if (!page) return [];\n\n  const height = getWrappingArea(page);\n  let splittedPage = splitNode(height, page);\n  const pages = [splittedPage[0]];\n  let nextPage = splittedPage[1];\n\n  while (nextPage !== null) {\n    splittedPage = splitNode(height, nextPage);\n    pages.push(splittedPage[0]);\n    nextPage = splittedPage[1];\n  }\n\n  return pages;\n};\n\nconst resolvePageSplitting = R.evolve({\n  children: R.map(\n    R.evolve({\n      children: R.compose(\n        R.flatten,\n        R.map(splitPage),\n      ),\n    }),\n  ),\n});\n\nexport default resolvePageSplitting;\n","import * as R from 'ramda';\n\nimport { resolvePageSize } from './resolvePageSizes';\nimport resolvePageBreaks from './resolvePageBreaks';\nimport resolvePageSplitting from './resolvePageSplitting';\n\nconst restorePageSize = R.evolve({\n  children: R.map(\n    R.evolve({\n      children: R.map(resolvePageSize('box')),\n    }),\n  ),\n});\n\nconst resolvePageWrapping = R.compose(\n  restorePageSize,\n  resolvePageSplitting,\n  resolvePageBreaks,\n);\n\nexport default resolvePageWrapping;\n","import * as R from 'ramda';\n\nimport isNote from '../node/isNote';\nimport isTextInstance from '../node/isTextInstance';\n\n/**\n * Get node underlying text value\n *\n * @param {Object} node\n * @returns {String} node text content\n */\nconst getNodeText = node =>\n  R.cond([\n    [R.is(String), R.identity],\n    [isTextInstance, R.prop('value')],\n    [\n      R.T,\n      R.compose(\n        getNodesText,\n        R.propOr([], 'children'),\n      ),\n    ],\n  ])(node);\n\n/**\n * Get underlying text value of several nodes\n *\n * @param {Array} nodes\n * @returns {String} nodes text content\n */\nconst getNodesText = R.compose(\n  R.join(''),\n  R.map(getNodeText),\n);\n\n/**\n * Transforms string to text instance\n *\n * @param {String} value\n * @returns {Array} text intance\n */\nconst wrapTextInstance = value => [{ type: 'TEXT_INSTANCE', value }];\n\n/**\n * Cast Note children as a text instance\n *\n * @param {Object} node\n * @returns {Object} node with resolved note children\n */\nconst resolveNoteChildren = node =>\n  R.ifElse(\n    isNote,\n    R.evolve({\n      children: R.compose(\n        wrapTextInstance,\n        getNodesText,\n      ),\n    }),\n    R.evolve({ children: R.map(resolveNoteChildren) }),\n  )(node);\n\nexport default resolveNoteChildren;\n","import * as R from 'ramda';\n\nimport matchPercent from '../utils/matchPercent';\n\n/*\n * Translates page percentage horizontal paddings in fixed ones\n *\n * @param {Object} page container\n * @param {String} padding value\n * @returns {Object} translated padding value\n */\nconst resolvePageHorizontalPadding = container => value => {\n  const match = matchPercent(value);\n  return match ? match.percent * container.width : value;\n};\n\n/**\n * Translates page percentage vertical paddings in fixed ones\n *\n * @param {Object} page container\n * @param {String} padding value\n * @returns {Object} translated padding value\n */\nconst resolvePageVerticalPadding = container => value => {\n  const match = matchPercent(value);\n  return match ? match.percent * container.height : value;\n};\n\n/**\n * Translates page percentage paddings in fixed ones\n *\n * @param {Object} page\n * @returns {Object} page with fixed paddings\n */\nconst resolvePagePaddings = page =>\n  R.evolve({\n    style: R.evolve({\n      paddingLeft: resolvePageHorizontalPadding(page.box),\n      paddingRight: resolvePageHorizontalPadding(page.box),\n      paddingTop: resolvePageVerticalPadding(page.box),\n      paddingBottom: resolvePageVerticalPadding(page.box),\n    }),\n  })(page);\n\n/**\n * Translates all pages percentage paddings in fixed ones\n *\n * @param {Object} document root\n * @returns {Object} document root with translated page paddings\n */\nexport default R.evolve({\n  children: R.map(\n    R.evolve({\n      children: R.map(resolvePagePaddings),\n    }),\n  ),\n});\n","import * as R from 'ramda';\n\nimport matchPercent from '../utils/matchPercent';\n\n/**\n *\n * @param {Object} container width and height\n * @param {String | Number} value border radius value\n * @returns {Number} fixed border radius value\n */\nconst resolveRadius = container => value => {\n  const match = matchPercent(value);\n  return match\n    ? match.percent * Math.min(container.width, container.height)\n    : value;\n};\n\n/**\n * Transforms percent border radius into fixed values\n *\n * @param {Object} node\n * @returns {Object} node\n */\nconst resolvePercentRadius = node =>\n  R.evolve({\n    children: R.map(resolvePercentRadius),\n    style: R.evolve({\n      borderTopLeftRadius: resolveRadius(node.box),\n      borderTopRightRadius: resolveRadius(node.box),\n      borderBottomRightRadius: resolveRadius(node.box),\n      borderBottomLeftRadius: resolveRadius(node.box),\n    }),\n  })(node);\n\nexport default resolvePercentRadius;\n","import * as R from 'ramda';\n\nimport matchPercent from '../utils/matchPercent';\n\n/**\n * Transform percent height into fixed\n *\n * @param {String | number} height\n * @return {number} height\n */\nconst transformHeight = pageArea => height => {\n  const match = matchPercent(height);\n  return match ? match.percent * pageArea : height;\n};\n\n/**\n * Get page area (height minus paddings)\n *\n * @param {Object} page\n * @return {number} page area\n */\nconst getPageArea = page => {\n  const pageHeight = R.path(['style', 'height'], page);\n  const pagePaddingTop = R.pathOr(0, ['style', 'paddingTop'], page);\n  const pagePaddingBottom = R.pathOr(0, ['style', 'paddingBottom'], page);\n  return pageHeight - pagePaddingTop - pagePaddingBottom;\n};\n\n/**\n * Checks if page has height\n *\n * @param {Object} page\n * @return {boolean} page has height\n */\nconst hasHeight = R.hasPath(['style', 'height']);\n\n/**\n * Transform node percent height to fixed\n *\n * @param {Object} page\n * @param {Object} node\n * @return {Object} transformed node\n */\nconst resolveNodePercentHeight = page => node => {\n  if (hasHeight(page)) {\n    const pageArea = getPageArea(page);\n    return R.evolve({ style: { height: transformHeight(pageArea) } })(node);\n  }\n\n  return node;\n};\n\n/**\n * Transform page immediate children with percent height to fixed\n *\n * @param {Object} page\n * @return {Object} transformed page\n */\nconst resolvePagePercentHeight = page =>\n  R.evolve({\n    children: R.map(resolveNodePercentHeight(page)),\n  })(page);\n\n/**\n * Transform all page immediate children with percent height to fixed\n *\n * @param {Object} document root\n * @return {Object} transformed document root\n */\nconst resolvePercentHeight = R.evolve({\n  children: R.map(\n    R.evolve({\n      children: R.map(resolvePagePercentHeight),\n    }),\n  ),\n});\n\nexport default resolvePercentHeight;\n","import * as R from 'ramda';\n\nimport { LINK } from '../constants';\n\n/**\n * Checks if node is link\n *\n * @param {Object} node\n * @returns {Boolean} is node link?\n */\nconst isLink = R.propEq('type', LINK);\n\nexport default isLink;\n","import * as R from 'ramda';\n\nimport { TEXT } from '../constants';\nimport isLink from '../node/isLink';\nimport isTextInstance from '../node/isTextInstance';\n\n/**\n * Checks if node has render prop\n *\n * @param {Object} node\n * @returns {Boolean} has render prop?\n */\nconst hasRenderProp = R.hasPath(['props', 'render']);\n\n/**\n * Checks if all children of node are text instances\n *\n * @param {Object} node\n * @returns {Boolean} are all children text instances?\n */\nconst hasTextInstanceChilds = R.compose(\n  R.all(isTextInstance),\n  R.propOr([], 'children'),\n);\n\n/**\n * If the Link has a strign child or render prop, substitute the instance by a Text,\n * that will ultimately render the inline Link via the textkit PDF renderer.\n *\n * @param {Object} node\n * @returns {Object} node with link substitution\n */\nconst resolveLinkSubstitution = node =>\n  R.evolve({\n    children: R.map(\n      R.ifElse(\n        R.both(isLink, R.either(hasRenderProp, hasTextInstanceChilds)),\n        R.assoc('type', TEXT),\n        resolveLinkSubstitution,\n      ),\n    ),\n  })(node);\n\nexport default resolveLinkSubstitution;\n","import * as R from 'ramda';\n\n/**\n * Translates relative coordinates to absolute coordinates\n *\n * @param {Object} root node\n * @returns {Object} root node with absolute coordinates\n */\nconst resolveAbsoluteCoordinates = node => {\n  const top = R.pathOr(0, ['box', 'top'], node);\n  const left = R.pathOr(0, ['box', 'left'], node);\n\n  return R.evolve({\n    children: R.map(\n      R.compose(\n        resolveAbsoluteCoordinates,\n        R.evolve({\n          box: R.evolve({\n            top: R.add(top),\n            bottom: R.add(top),\n            left: R.add(left),\n            right: R.add(left),\n          }),\n          origin: R.evolve({\n            top: R.add(top),\n            left: R.add(left),\n          }),\n        }),\n      ),\n    ),\n  })(node);\n};\n\nexport default resolveAbsoluteCoordinates;\n","import * as R from 'ramda';\n\n/**\n * Performs right-to-left function composition with async functions support\n *\n * @param  {...any} functions\n */\nconst asyncCompose = (...fns) => async value => {\n  for (const fn of R.reverse(fns)) value = await fn(value);\n  return value;\n};\n\nexport default asyncCompose;\n","import * as R from 'ramda';\n\nimport resolveAssets from './resolveAssets';\nimport resolveStyles from './resolveStyles';\nimport resolveZIndex from './resolveZIndex';\nimport resolveRulers from './resolveRulers';\nimport resolveOrigins from './resolveOrigins';\nimport resolvePageSizes from './resolvePageSizes';\nimport resolveDimensions from './resolveDimensions';\nimport resolveTextLayout from './resolveTextLayout';\nimport resolveInheritance from './resolveInheritance';\nimport resolvePageMargins from './resolvePageMargins';\nimport resolvePageWrapping from './resolvePageWrapping';\nimport resolveNoteChildren from './resolveNoteChildren';\nimport resolvePagePaddings from './resolvePagePaddings';\nimport resolvePercentRadius from './resolvePercentRadius';\nimport resolvePercentHeight from './resolvePercentHeight';\nimport resolveLinkSubstitution from './resolveLinkSubstitution';\nimport resolveAbsoluteCoordinates from './resolveAbsoluteCoordinates';\nimport asyncCompose from '../utils/asyncCompose';\n\nconst startTimer = name => R.tap(() => console.time(name));\nconst endTimer = name => R.tap(() => console.timeEnd(name));\n\nconst resolvePageSizeStyle = resolvePageSizes('style');\n\nconst layout = asyncCompose(\n  resolveAbsoluteCoordinates,\n  resolveRulers,\n  resolveOrigins,\n  endTimer('resolvePageBreaks'),\n  resolvePageWrapping,\n  startTimer('resolvePageBreaks'),\n  resolveTextLayout,\n  resolvePercentRadius,\n  resolveZIndex,\n  resolveDimensions,\n  resolveAssets,\n  resolveInheritance,\n  resolvePercentHeight,\n  resolvePagePaddings,\n  resolveStyles,\n  resolveNoteChildren,\n  resolveLinkSubstitution,\n  resolvePageMargins,\n  resolvePageSizeStyle,\n);\n\nexport default layout;\n","import * as R from 'ramda';\n\nconst save = ctx => R.tap(() => ctx.save());\n\nexport default save;\n","import * as R from 'ramda';\n\nconst restore = ctx => R.tap(() => ctx.restore());\n\nexport default restore;\n","import * as R from 'ramda';\nimport PDFRenderer from '@react-pdf/textkit/renderers/pdf';\n\nconst renderText = (ctx, node) => {\n  const { top, left } = node.box;\n  const paddingTop = R.pathOr(0, ['box', 'paddingTop'], node);\n  const paddingLeft = R.pathOr(0, ['box', 'paddingLeft'], node);\n  const initialY = node.lines[0] ? node.lines[0].box.y : 0;\n\n  ctx.save();\n  ctx.translate(left + paddingLeft, top + paddingTop - initialY);\n  PDFRenderer.render(ctx, [node.lines]);\n  ctx.restore();\n\n  return node;\n};\n\nexport default R.curryN(2, renderText);\n","import * as R from 'ramda';\n\nconst renderPage = (ctx, node) => {\n  const { width, height } = node.box;\n\n  ctx.addPage({ size: [width, height], margin: 0 });\n\n  return node;\n};\n\nexport default R.curryN(2, renderPage);\n","const PROTOCOL_REGEXP = /^([a-z]+\\:(\\/\\/)?)/i;\n\n/**\n * Add protocol th URL if valid\n *\n * @param {String} value url\n * @returns {String} corrected url\n */\nexport const getURL = value => {\n  if (!value) return '';\n\n  if (typeof value === 'string' && !value.match(PROTOCOL_REGEXP)) {\n    return `http://${value}`;\n  }\n\n  return value;\n};\n","import * as R from 'ramda';\n\nimport { getURL } from '../utils/url';\n\nconst getSource = R.compose(\n  getURL,\n  R.either(R.path(['props', 'src']), R.path(['props', 'href'])),\n);\n\nexport default getSource;\n","import * as R from 'ramda';\n\nimport getSource from '../link/getSource';\n\nconst renderLink = (ctx, node) => {\n  const { top, left, width, height } = node.box;\n  const src = getSource(node);\n\n  ctx.link(left, top, width, height, src);\n\n  return node;\n};\n\nexport default R.curryN(2, renderLink);\n","import * as R from 'ramda';\n\nconst renderNote = (ctx, node) => {\n  const { top, left } = node.box;\n  const value = node.children[0] ? node.children[0].value : '';\n\n  ctx.note(left, top, 0, 0, value);\n\n  return node;\n};\n\nexport default R.curryN(2, renderNote);\n","import * as R from 'ramda';\n\n// This constant is used to approximate a symmetrical arc using a cubic\n// Bezier curve.\nconst KAPPA = 4.0 * ((Math.sqrt(2) - 1.0) / 3.0);\n\nconst clipNode = (ctx, node) => {\n  const { top, left, width, height } = node.box;\n\n  const {\n    borderTopLeftRadius = 0,\n    borderTopRightRadius = 0,\n    borderBottomRightRadius = 0,\n    borderBottomLeftRadius = 0,\n  } = node.style;\n\n  // Border top\n  const rtr = Math.min(borderTopRightRadius, 0.5 * width, 0.5 * height);\n  const ctr = rtr * (1.0 - KAPPA);\n\n  ctx.moveTo(left + rtr, top);\n  ctx.lineTo(left + width - rtr, top);\n  ctx.bezierCurveTo(\n    left + width - ctr,\n    top,\n    left + width,\n    top + ctr,\n    left + width,\n    top + rtr,\n  );\n\n  // Border right\n  const rbr = Math.min(borderBottomRightRadius, 0.5 * width, 0.5 * height);\n  const cbr = rbr * (1.0 - KAPPA);\n\n  ctx.lineTo(left + width, top + height - rbr);\n  ctx.bezierCurveTo(\n    left + width,\n    top + height - cbr,\n    left + width - cbr,\n    top + height,\n    left + width - rbr,\n    top + height,\n  );\n\n  // Border bottom\n  const rbl = Math.min(borderBottomLeftRadius, 0.5 * width, 0.5 * height);\n  const cbl = rbl * (1.0 - KAPPA);\n\n  ctx.lineTo(left + rbl, top + height);\n  ctx.bezierCurveTo(\n    left + cbl,\n    top + height,\n    left,\n    top + height - cbl,\n    left,\n    top + height - rbl,\n  );\n\n  // Border left\n  const rtl = Math.min(borderTopLeftRadius, 0.5 * width, 0.5 * height);\n  const ctl = rtl * (1.0 - KAPPA);\n\n  ctx.lineTo(left, top + rtl);\n  ctx.bezierCurveTo(left, top + ctl, left + ctl, top, left + rtl, top);\n  ctx.closePath();\n  ctx.clip();\n\n  return node;\n};\n\nexport default R.curryN(2, clipNode);\n","import matchPercent from '../utils/matchPercent';\n\nconst isNumeric = n => {\n  return !isNaN(parseFloat(n)) && isFinite(n);\n};\n\nconst applyContainObjectFit = (cw, ch, iw, ih, px, py) => {\n  const cr = cw / ch;\n  const ir = iw / ih;\n\n  const pxp = matchPercent(px);\n  const pyp = matchPercent(py);\n  const pxv = pxp ? pxp.percent : 0.5;\n  const pyv = pyp ? pyp.percent : 0.5;\n\n  if (cr > ir) {\n    const height = ch;\n    const width = height * ir;\n    const yOffset = isNumeric(py) ? py : 0;\n    const xOffset = isNumeric(px) ? px : (cw - width) * pxv;\n\n    return { width, height, xOffset, yOffset };\n  } else {\n    const width = cw;\n    const height = width / ir;\n    const xOffset = isNumeric(px) ? px : 0;\n    const yOffset = isNumeric(py) ? py : (ch - height) * pyv;\n\n    return { width, height, yOffset, xOffset };\n  }\n};\n\nconst applyNoneObjectFit = (cw, ch, iw, ih, px, py) => {\n  const width = iw;\n  const height = ih;\n  const pxp = matchPercent(px);\n  const pyp = matchPercent(py);\n  const pxv = pxp ? pxp.percent : 0.5;\n  const pyv = pyp ? pyp.percent : 0.5;\n  const xOffset = isNumeric(px) ? px : (cw - width) * pxv;\n  const yOffset = isNumeric(py) ? py : (ch - height) * pyv;\n\n  return { width, height, xOffset, yOffset };\n};\n\nconst applyCoverObjectFit = (cw, ch, iw, ih, px, py) => {\n  const ir = iw / ih;\n  const cr = cw / ch;\n\n  const pxp = matchPercent(px);\n  const pyp = matchPercent(py);\n  const pxv = pxp ? pxp.percent : 0.5;\n  const pyv = pyp ? pyp.percent : 0.5;\n\n  if (cr > ir) {\n    const width = cw;\n    const height = width / ir;\n    const xOffset = isNumeric(px) ? px : 0;\n    const yOffset = isNumeric(py) ? py : (ch - height) * pyv;\n    return { width, height, yOffset, xOffset };\n  } else {\n    const height = ch;\n    const width = height * ir;\n    const xOffset = isNumeric(px) ? px : (cw - width) * pxv;\n    const yOffset = isNumeric(py) ? py : 0;\n    return { width, height, xOffset, yOffset };\n  }\n};\n\nconst applyScaleDownObjectFit = (cw, ch, iw, ih, px, py) => {\n  const containDimension = applyContainObjectFit(cw, ch, iw, ih, px, py);\n  const noneDimension = applyNoneObjectFit(cw, ch, iw, ih, px, py);\n\n  return containDimension.width < noneDimension.width\n    ? containDimension\n    : noneDimension;\n};\n\nconst applyFillObjectFit = (cw, ch, px, py) => {\n  return {\n    width: cw,\n    height: ch,\n    xOffset: matchPercent(px) ? 0 : px || 0,\n    yOffset: matchPercent(py) ? 0 : py || 0,\n  };\n};\n\nconst resolveObjectFit = (type = 'fill', cw, ch, iw, ih, px, py) => {\n  switch (type) {\n    case 'contain':\n      return applyContainObjectFit(cw, ch, iw, ih, px, py);\n    case 'cover':\n      return applyCoverObjectFit(cw, ch, iw, ih, px, py);\n    case 'none':\n      return applyNoneObjectFit(cw, ch, iw, ih, px, py);\n    case 'scale-down':\n      return applyScaleDownObjectFit(cw, ch, iw, ih, px, py);\n    default:\n      return applyFillObjectFit(cw, ch, px, py);\n  }\n};\n\nexport default resolveObjectFit;\n","import * as R from 'ramda';\n\nimport save from './save';\nimport restore from './restore';\nimport clipNode from './clipNode';\nimport warning from '../utils/warning';\nimport resolveObjectFit from '../image/resolveObjectFit';\n\nconst drawImage = ctx => node => {\n  const { left, top } = node.box;\n  const { opacity, objectPositionX, objectPositionY } = node.style;\n  const paddingTop = node.box.paddingLeft || 0;\n  const paddingRight = node.box.paddingRight || 0;\n  const paddingBottom = node.box.paddingBottom || 0;\n  const paddingLeft = node.box.paddingLeft || 0;\n\n  const { width, height, xOffset, yOffset } = resolveObjectFit(\n    node.style.objectFit,\n    node.box.width - paddingLeft - paddingRight,\n    node.box.height - paddingTop - paddingBottom,\n    node.image.width,\n    node.image.height,\n    objectPositionX,\n    objectPositionY,\n  );\n\n  if (node.image.data) {\n    if (width !== 0 && height !== 0) {\n      ctx\n        .fillOpacity(opacity || 1)\n        .image(\n          node.image.data,\n          left + paddingLeft + xOffset,\n          top + paddingTop + yOffset,\n          {\n            width,\n            height,\n          },\n        );\n    } else {\n      warning(\n        false,\n        `Image with src '${node.props.src}' skipped due to invalid dimensions`,\n      );\n    }\n  }\n\n  return node;\n};\n\nconst renderImage = (ctx, node) => {\n  R.compose(\n    restore(ctx),\n    drawImage(ctx),\n    clipNode(ctx),\n    save(ctx),\n  )(node);\n\n  return node;\n};\n\nexport default R.curryN(2, renderImage);\n","export const availableMethods = [\n  'dash',\n  'clip',\n  'save',\n  'path',\n  'fill',\n  'font',\n  'text',\n  'rect',\n  'scale',\n  'moveTo',\n  'lineTo',\n  'stroke',\n  'rotate',\n  'circle',\n  'lineCap',\n  'opacity',\n  'ellipse',\n  'polygon',\n  'restore',\n  'lineJoin',\n  'fontSize',\n  'fillColor',\n  'lineWidth',\n  'translate',\n  'miterLimit',\n  'strokeColor',\n  'fillOpacity',\n  'roundedRect',\n  'strokeOpacity',\n  'bezierCurveTo',\n  'quadraticCurveTo',\n  'linearGradient',\n  'radialGradient',\n];\n\nconst painter = function(ctx) {\n  const p = availableMethods.reduce(\n    (acc, prop) => ({\n      ...acc,\n      [prop]: (...args) => {\n        ctx[prop](...args);\n        return p;\n      },\n    }),\n    {},\n  );\n\n  return p;\n};\n\nexport default painter;\n","import * as R from 'ramda';\n\nimport painter from '../canvas/painter';\nimport warning from '../utils/warning';\n\nconst defaultsZero = R.pathOr(0);\n\nconst renderCanvas = (ctx, node) => {\n  const { top, left, width, height } = node.box;\n\n  const paddingLeft = defaultsZero('paddingLeft', node.box);\n  const paddingRight = defaultsZero('paddingRight', node.box);\n  const paddingTop = defaultsZero('paddingTop', node.box);\n  const paddingBottom = defaultsZero('paddingBottom', node.box);\n\n  const availableWidth = width - paddingLeft - paddingRight;\n  const availableHeight = height - paddingTop - paddingBottom;\n\n  warning(\n    availableWidth && availableHeight,\n    'Canvas element has null width or height. Please provide valid values via the `style` prop in order to correctly render it.',\n  );\n\n  ctx.save().translate(left + paddingLeft, top + paddingTop);\n\n  if (node.props.paint) {\n    node.props.paint(painter(ctx), availableWidth, availableHeight);\n  }\n\n  ctx.restore();\n\n  return node;\n};\n\nexport default R.curryN(2, renderCanvas);\n","import * as R from 'ramda';\n\nimport matchPercent from '../utils/matchPercent';\nimport hasVerticalRuler from '../node/hasVerticalRuler';\nimport hasHorizontalRuler from '../node/hasHorizontalRuler';\nimport {\n  RULER_WIDTH,\n  RULER_COLOR,\n  LINE_COLOR,\n  GRID_COLOR,\n  LINE_WIDTH,\n  RULER_FONT_SIZE,\n  DEFAULT_RULER_STEPS,\n} from '../constants';\n\nconst range = (max, steps) =>\n  Array.from({ length: Math.ceil(max / steps) }, (_, i) => i * steps);\n\nconst matchPercentage = value => {\n  const match = matchPercent(value);\n  return match ? 100 / match.value : null;\n};\n\nconst getVerticalSteps = page => {\n  const value =\n    page.props.horizontalRulerSteps ||\n    page.props.rulerSteps ||\n    DEFAULT_RULER_STEPS;\n\n  if (typeof value === 'string') {\n    const percentage = matchPercentage(value);\n    if (percentage) {\n      const width = page.box.width - (hasVerticalRuler(page) ? RULER_WIDTH : 0);\n      return width / percentage;\n    }\n    throw new Error('Page: Invalid horizontal steps value');\n  }\n\n  return value;\n};\n\nconst getHorizontalSteps = page => {\n  const value =\n    page.props.verticalRulerSteps ||\n    page.props.rulerSteps ||\n    DEFAULT_RULER_STEPS;\n\n  if (typeof value === 'string') {\n    const percentage = matchPercentage(value);\n    if (percentage) {\n      const height =\n        page.box.height - (hasVerticalRuler(page) ? RULER_WIDTH : 0);\n      return height / percentage;\n    }\n    throw new Error('Page: Invalid horizontal steps value');\n  }\n\n  return value;\n};\n\nconst renderVerticalRuler = ctx => page => {\n  const width = page.box.width;\n  const height = page.box.height;\n  const offset = hasHorizontalRuler(page) ? RULER_WIDTH : 0;\n  const hRange = range(width, getVerticalSteps(page));\n\n  ctx\n    .rect(offset, 0, width, RULER_WIDTH)\n    .fill(RULER_COLOR)\n    .moveTo(offset, RULER_WIDTH)\n    .lineTo(width, RULER_WIDTH)\n    .stroke(LINE_COLOR);\n\n  hRange.map(step => {\n    ctx\n      .moveTo(offset + step, 0)\n      .lineTo(offset + step, RULER_WIDTH)\n      .stroke(LINE_COLOR)\n      .fillColor('black')\n      .text(`${Math.round(step)}`, offset + step + 1, 1);\n\n    if (step !== 0) {\n      ctx\n        .moveTo(offset + step, RULER_WIDTH)\n        .lineTo(offset + step, height)\n        .stroke(GRID_COLOR);\n    }\n  });\n\n  return page;\n};\n\nconst renderHorizontalRuler = ctx => page => {\n  const width = page.box.width;\n  const height = page.box.height;\n  const offset = hasVerticalRuler(page) ? RULER_WIDTH : 0;\n  const hRange = range(height, getHorizontalSteps(page));\n\n  ctx\n    .rect(0, offset, RULER_WIDTH, height)\n    .fill(RULER_COLOR)\n    .moveTo(RULER_WIDTH, hasHorizontalRuler(page) ? RULER_WIDTH : 0)\n    .lineTo(RULER_WIDTH, height)\n    .stroke(LINE_COLOR);\n\n  hRange.map(step => {\n    ctx\n      .moveTo(0, offset + step)\n      .lineTo(RULER_WIDTH, offset + step)\n      .stroke(LINE_COLOR)\n      .fillColor('black')\n      .text(`${Math.round(step)}`, 1, offset + step + 1);\n\n    if (step !== 0) {\n      ctx\n        .moveTo(RULER_WIDTH, offset + step)\n        .lineTo(width, offset + step)\n        .stroke(GRID_COLOR);\n    }\n  });\n\n  return page;\n};\n\nconst renderRulers = (ctx, page) => {\n  ctx\n    .save()\n    .lineWidth(LINE_WIDTH)\n    .fontSize(RULER_FONT_SIZE)\n    .opacity(1);\n\n  R.compose(\n    R.when(hasVerticalRuler, renderVerticalRuler(ctx)),\n    R.when(hasHorizontalRuler, renderHorizontalRuler(ctx)),\n  )(page);\n\n  ctx.restore();\n\n  return page;\n};\n\nexport default R.curryN(2, renderRulers);\n","import * as R from 'ramda';\n\nconst getDocumentProp = target => (or, prop) =>\n  R.pathOr(or, ['children', 0, 'props', prop], target);\n\nconst setPDFMetadata = target => (key, value) => {\n  if (value) target.info[key] = value;\n};\n\n/**\n * Set document instance metadata\n *\n * @param {Object} ctx document instance\n * @param {Object} root document root\n */\nconst addMetadata = (ctx, root) => {\n  const getProp = getDocumentProp(root);\n  const setProp = setPDFMetadata(ctx);\n\n  const title = getProp(null, 'title');\n  const author = getProp(null, 'author');\n  const subject = getProp(null, 'subject');\n  const keywords = getProp(null, 'keywords');\n  const creator = getProp('react-pdf', 'creator');\n  const producer = getProp('react-pdf', 'producer');\n\n  setProp('Title', title);\n  setProp('Author', author);\n  setProp('Subject', subject);\n  setProp('Keywords', keywords);\n  setProp('Creator', creator);\n  setProp('Producer', producer);\n\n  return root;\n};\n\nexport default R.curryN(2, addMetadata);\n","import * as R from 'ramda';\n\nconst CONTENT_COLOR = '#a1c6e7';\nconst PADDING_COLOR = '#c4deb9';\nconst MARGIN_COLOR = '#f8cca1';\n\nconst shouldDebug = R.pathEq(['props', 'debug'], true);\n\n// TODO: Draw debug boxes using clipping to enhance quality\n\nconst debugContent = (ctx, node) => {\n  const {\n    left,\n    top,\n    width,\n    height,\n    paddingLeft,\n    paddingTop,\n    paddingRight,\n    paddingBottom,\n  } = node.box;\n\n  ctx\n    .fillColor(CONTENT_COLOR)\n    .opacity(0.5)\n    .rect(\n      left + paddingLeft,\n      top + paddingTop,\n      width - paddingLeft - paddingRight,\n      height - paddingTop - paddingBottom,\n    )\n    .fill();\n};\n\nconst debugPadding = (ctx, node) => {\n  const {\n    left,\n    top,\n    width,\n    height,\n    paddingLeft,\n    paddingTop,\n    paddingRight,\n    paddingBottom,\n  } = node.box;\n\n  ctx.fillColor(PADDING_COLOR).opacity(0.5);\n\n  // Padding top\n  ctx\n    .rect(\n      left + paddingLeft,\n      top,\n      width - paddingRight - paddingLeft,\n      paddingTop,\n    )\n    .fill();\n\n  // Padding left\n  ctx.rect(left, top, paddingLeft, height).fill();\n\n  // Padding right\n  ctx.rect(left + width - paddingRight, top, paddingRight, height).fill();\n\n  // Padding bottom\n  ctx\n    .rect(\n      left + paddingLeft,\n      top + height - paddingBottom,\n      width - paddingRight - paddingLeft,\n      paddingBottom,\n    )\n    .fill();\n};\n\nconst debugMargin = (ctx, node) => {\n  const {\n    left,\n    top,\n    width,\n    height,\n    marginLeft,\n    marginTop,\n    marginRight,\n    marginBottom,\n  } = node.box;\n  ctx.fillColor(MARGIN_COLOR).opacity(0.5);\n\n  // Margin top\n  ctx.rect(left, top - marginTop, width, marginTop).fill();\n\n  // Margin left\n  ctx\n    .rect(\n      left - marginLeft,\n      top - marginTop,\n      marginLeft,\n      height + marginTop + marginBottom,\n    )\n    .fill();\n\n  // Margin right\n  ctx\n    .rect(\n      left + width,\n      top - marginTop,\n      marginRight,\n      height + marginTop + marginBottom,\n    )\n    .fill();\n\n  // Margin bottom\n  ctx.rect(left, top + height, width, marginBottom).fill();\n};\n\nconst debugText = (ctx, node) => {\n  const {\n    left,\n    top,\n    width,\n    height,\n    marginLeft,\n    marginTop,\n    marginRight,\n    marginBottom,\n  } = node.box;\n\n  const roundedWidth = Math.round(width + marginLeft + marginRight);\n  const roundedHeight = Math.round(height + marginTop + marginBottom);\n\n  ctx\n    .fontSize(4)\n    .opacity(1)\n    .fillColor('black')\n    .text(\n      `${roundedWidth} x ${roundedHeight}`,\n      left - marginLeft,\n      Math.max(top - marginTop - 4, 1),\n    );\n};\n\nconst debugOrigin = (ctx, node) => {\n  if (node.origin) {\n    ctx\n      .circle(node.origin.left, node.origin.top, 3)\n      .fill('red')\n      .circle(node.origin.left, node.origin.top, 5)\n      .stroke('red');\n  }\n};\n\nconst renderDebug = (ctx, node) => {\n  if (!shouldDebug(node)) return node;\n\n  ctx.save();\n\n  debugContent(ctx, node);\n  debugPadding(ctx, node);\n  debugMargin(ctx, node);\n  debugText(ctx, node);\n  debugOrigin(ctx, node);\n\n  ctx.restore();\n\n  return node;\n};\n\nexport default R.curryN(2, renderDebug);\n","import * as R from 'ramda';\n\n// Ref: https://www.w3.org/TR/css-backgrounds-3/#borders\n\n// This constant is used to approximate a symmetrical arc using a cubic Bezier curve.\nconst KAPPA = 4.0 * ((Math.sqrt(2) - 1.0) / 3.0);\n\nconst clipBorderTop = (ctx, layout, style, rtr, rtl) => {\n  const { top, left, width, height } = layout;\n  const { borderTopWidth, borderRightWidth, borderLeftWidth } = style;\n\n  // Clip outer top border edge\n  ctx.moveTo(left + rtl, top);\n  ctx.lineTo(left + width - rtr, top);\n\n  // Ellipse coefficients outer top right cap\n  const c0 = rtr * (1.0 - KAPPA);\n\n  // Clip outer top right cap\n  ctx.bezierCurveTo(\n    left + width - c0,\n    top,\n    left + width,\n    top + c0,\n    left + width,\n    top + rtr,\n  );\n\n  // Move down in case the margin exceedes the radius\n  const topRightYCoord = top + Math.max(borderTopWidth, rtr);\n  ctx.lineTo(left + width, topRightYCoord);\n\n  // Clip inner top right cap\n  ctx.lineTo(left + width - borderRightWidth, topRightYCoord);\n\n  // Ellipse coefficients inner top right cap\n  const innerTopRightRadiusX = Math.max(rtr - borderRightWidth, 0);\n  const innerTopRightRadiusY = Math.max(rtr - borderTopWidth, 0);\n  const c1 = innerTopRightRadiusX * (1.0 - KAPPA);\n  const c2 = innerTopRightRadiusY * (1.0 - KAPPA);\n\n  // Clip inner top right cap\n  ctx.bezierCurveTo(\n    left + width - borderRightWidth,\n    top + borderTopWidth + c2,\n    left + width - borderRightWidth - c1,\n    top + borderTopWidth,\n    left + width - borderRightWidth - innerTopRightRadiusX,\n    top + borderTopWidth,\n  );\n\n  // Clip inner top border edge\n  ctx.lineTo(left + Math.max(rtl, borderLeftWidth), top + borderTopWidth);\n\n  // Ellipse coefficients inner top left cap\n  const innerTopLeftRadiusX = Math.max(rtl - borderLeftWidth, 0);\n  const innerTopLeftRadiusY = Math.max(rtl - borderTopWidth, 0);\n  const c3 = innerTopLeftRadiusX * (1.0 - KAPPA);\n  const c4 = innerTopLeftRadiusY * (1.0 - KAPPA);\n  const topLeftYCoord = top + Math.max(borderTopWidth, rtl);\n\n  // Clip inner top left cap\n  ctx.bezierCurveTo(\n    left + borderLeftWidth + c3,\n    top + borderTopWidth,\n    left + borderLeftWidth,\n    top + borderTopWidth + c4,\n    left + borderLeftWidth,\n    topLeftYCoord,\n  );\n  ctx.lineTo(left, topLeftYCoord);\n\n  // Move down in case the margin exceedes the radius\n  ctx.lineTo(left, top + rtl);\n\n  // Ellipse coefficients outer top left cap\n  const c5 = rtl * (1.0 - KAPPA);\n\n  // Clip outer top left cap\n  ctx.bezierCurveTo(left, top + c5, left + c5, top, left + rtl, top);\n  ctx.closePath();\n  ctx.clip();\n\n  // Clip border top cap joins\n  if (borderRightWidth) {\n    const trSlope = -borderTopWidth / borderRightWidth;\n    ctx.moveTo(left + width / 2, trSlope * (-width / 2) + top);\n    ctx.lineTo(left + width, top);\n    ctx.lineTo(left, top);\n    ctx.lineTo(left, top + height);\n    ctx.closePath();\n    ctx.clip();\n  }\n\n  if (borderLeftWidth) {\n    const trSlope = -borderTopWidth / borderLeftWidth;\n    ctx.moveTo(left + width / 2, trSlope * (-width / 2) + top);\n    ctx.lineTo(left, top);\n    ctx.lineTo(left + width, top);\n    ctx.lineTo(left + width, top + height);\n    ctx.closePath();\n    ctx.clip();\n  }\n};\n\nconst fillBorderTop = (ctx, layout, style, rtr, rtl) => {\n  const { top, left, width } = layout;\n  const {\n    borderTopColor,\n    borderTopWidth,\n    borderTopStyle,\n    borderRightWidth,\n    borderLeftWidth,\n  } = style;\n\n  const c0 = rtl * (1.0 - KAPPA);\n  const c1 = rtr * (1.0 - KAPPA);\n\n  ctx.moveTo(left, top + Math.max(rtl, borderTopWidth));\n  ctx.bezierCurveTo(left, top + c0, left + c0, top, left + rtl, top);\n  ctx.lineTo(left + width - rtr, top);\n  ctx.bezierCurveTo(\n    left + width - c1,\n    top,\n    left + width,\n    top + c1,\n    left + width,\n    top + rtr,\n  );\n\n  ctx.strokeColor(borderTopColor);\n  ctx.lineWidth(\n    Math.max(borderRightWidth, borderTopWidth, borderLeftWidth) * 2,\n  );\n\n  if (borderTopStyle === 'dashed') {\n    ctx.dash(borderTopWidth * 2, { space: borderTopWidth * 1.2 });\n  } else if (borderTopStyle === 'dotted') {\n    ctx.dash(borderTopWidth, { space: borderTopWidth * 1.2 });\n  }\n\n  ctx.stroke();\n  ctx.undash();\n};\n\nconst clipBorderRight = (ctx, layout, style, rtr, rbr) => {\n  const { top, left, width, height } = layout;\n  const { borderTopWidth, borderRightWidth, borderBottomWidth } = style;\n\n  // Clip outer right border edge\n  ctx.moveTo(left + width, top + rtr);\n  ctx.lineTo(left + width, top + height - rbr);\n\n  // Ellipse coefficients outer bottom right cap\n  const c0 = rbr * (1.0 - KAPPA);\n\n  // Clip outer top right cap\n  ctx.bezierCurveTo(\n    left + width,\n    top + height - c0,\n    left + width - c0,\n    top + height,\n    left + width - rbr,\n    top + height,\n  );\n\n  // Move left in case the margin exceedes the radius\n  const topBottomXCoord = left + width - Math.max(borderRightWidth, rbr);\n  ctx.lineTo(topBottomXCoord, top + height);\n\n  // Clip inner bottom right cap\n  ctx.lineTo(topBottomXCoord, top + height - borderBottomWidth);\n\n  // Ellipse coefficients inner bottom right cap\n  const innerBottomRightRadiusX = Math.max(rbr - borderRightWidth, 0);\n  const innerBottomRightRadiusY = Math.max(rbr - borderBottomWidth, 0);\n  const c1 = innerBottomRightRadiusX * (1.0 - KAPPA);\n  const c2 = innerBottomRightRadiusY * (1.0 - KAPPA);\n\n  // Clip inner top right cap\n  ctx.bezierCurveTo(\n    left + width - borderRightWidth - c1,\n    top + height - borderBottomWidth,\n    left + width - borderRightWidth,\n    top + height - borderBottomWidth - c2,\n    left + width - borderRightWidth,\n    top + height - Math.max(rbr, borderBottomWidth),\n  );\n\n  // Clip inner right border edge\n  ctx.lineTo(\n    left + width - borderRightWidth,\n    top + Math.max(rtr, borderTopWidth),\n  );\n\n  // Ellipse coefficients inner top right cap\n  const innerTopRightRadiusX = Math.max(rtr - borderRightWidth, 0);\n  const innerTopRightRadiusY = Math.max(rtr - borderTopWidth, 0);\n  const c3 = innerTopRightRadiusX * (1.0 - KAPPA);\n  const c4 = innerTopRightRadiusY * (1.0 - KAPPA);\n  const topRightXCoord = left + width - Math.max(rtr, borderRightWidth);\n\n  // Clip inner top left cap\n  ctx.bezierCurveTo(\n    left + width - borderRightWidth,\n    top + borderTopWidth + c4,\n    left + width - borderRightWidth - c3,\n    top + borderTopWidth,\n    topRightXCoord,\n    top + borderTopWidth,\n  );\n  ctx.lineTo(topRightXCoord, top);\n\n  // Move right in case the margin exceedes the radius\n  ctx.lineTo(left + width - rtr, top);\n\n  // Ellipse coefficients outer top right cap\n  const c5 = rtr * (1.0 - KAPPA);\n\n  // Clip outer top right cap\n  ctx.bezierCurveTo(\n    left + width - c5,\n    top,\n    left + width,\n    top + c5,\n    left + width,\n    top + rtr,\n  );\n\n  ctx.closePath();\n  ctx.clip();\n\n  // Clip border right cap joins\n  if (borderTopWidth) {\n    const trSlope = -borderTopWidth / borderRightWidth;\n    ctx.moveTo(left + width / 2, trSlope * (-width / 2) + top);\n    ctx.lineTo(left + width, top);\n    ctx.lineTo(left + width, top + height);\n    ctx.lineTo(left, top + height);\n    ctx.closePath();\n    ctx.clip();\n  }\n\n  if (borderBottomWidth) {\n    const brSlope = borderBottomWidth / borderRightWidth;\n    ctx.moveTo(left + width / 2, brSlope * (-width / 2) + top + height);\n    ctx.lineTo(left + width, top + height);\n    ctx.lineTo(left + width, top);\n    ctx.lineTo(left, top);\n    ctx.closePath();\n    ctx.clip();\n  }\n};\n\nconst fillBorderRight = (ctx, layout, style, rtr, rbr) => {\n  const { top, left, width, height } = layout;\n  const {\n    borderRightColor,\n    borderRightStyle,\n    borderRightWidth,\n    borderTopWidth,\n    borderBottomWidth,\n  } = style;\n\n  const c0 = rbr * (1.0 - KAPPA);\n  const c1 = rtr * (1.0 - KAPPA);\n\n  ctx.moveTo(left + width - rtr, top);\n  ctx.bezierCurveTo(\n    left + width - c1,\n    top,\n    left + width,\n    top + c1,\n    left + width,\n    top + rtr,\n  );\n  ctx.lineTo(left + width, top + height - rbr);\n  ctx.bezierCurveTo(\n    left + width,\n    top + height - c0,\n    left + width - c0,\n    top + height,\n    left + width - rbr,\n    top + height,\n  );\n\n  ctx.strokeColor(borderRightColor);\n  ctx.lineWidth(\n    Math.max(borderRightWidth, borderTopWidth, borderBottomWidth) * 2,\n  );\n\n  if (borderRightStyle === 'dashed') {\n    ctx.dash(borderRightWidth * 2, { space: borderRightWidth * 1.2 });\n  } else if (borderRightStyle === 'dotted') {\n    ctx.dash(borderRightWidth, { space: borderRightWidth * 1.2 });\n  }\n\n  ctx.stroke();\n  ctx.undash();\n};\n\nconst clipBorderBottom = (ctx, layout, style, rbl, rbr) => {\n  const { top, left, width, height } = layout;\n  const { borderBottomWidth, borderRightWidth, borderLeftWidth } = style;\n\n  // Clip outer top border edge\n  ctx.moveTo(left + width - rbr, top + height);\n  ctx.lineTo(left + rbl, top + height);\n\n  // Ellipse coefficients outer top right cap\n  const c0 = rbl * (1.0 - KAPPA);\n\n  // Clip outer top right cap\n  ctx.bezierCurveTo(\n    left + c0,\n    top + height,\n    left,\n    top + height - c0,\n    left,\n    top + height - rbl,\n  );\n\n  // Move up in case the margin exceedes the radius\n  const bottomLeftYCoord = top + height - Math.max(borderBottomWidth, rbl);\n  ctx.lineTo(left, bottomLeftYCoord);\n\n  // Clip inner bottom left cap\n  ctx.lineTo(left + borderLeftWidth, bottomLeftYCoord);\n\n  // Ellipse coefficients inner top right cap\n  const innerBottomLeftRadiusX = Math.max(rbl - borderLeftWidth, 0);\n  const innerBottomLeftRadiusY = Math.max(rbl - borderBottomWidth, 0);\n  const c1 = innerBottomLeftRadiusX * (1.0 - KAPPA);\n  const c2 = innerBottomLeftRadiusY * (1.0 - KAPPA);\n\n  // Clip inner bottom left cap\n  ctx.bezierCurveTo(\n    left + borderLeftWidth,\n    top + height - borderBottomWidth - c2,\n    left + borderLeftWidth + c1,\n    top + height - borderBottomWidth,\n    left + borderLeftWidth + innerBottomLeftRadiusX,\n    top + height - borderBottomWidth,\n  );\n\n  // Clip inner bottom border edge\n  ctx.lineTo(\n    left + width - Math.max(rbr, borderRightWidth),\n    top + height - borderBottomWidth,\n  );\n\n  // Ellipse coefficients inner top left cap\n  const innerBottomRightRadiusX = Math.max(rbr - borderRightWidth, 0);\n  const innerBottomRightRadiusY = Math.max(rbr - borderBottomWidth, 0);\n  const c3 = innerBottomRightRadiusX * (1.0 - KAPPA);\n  const c4 = innerBottomRightRadiusY * (1.0 - KAPPA);\n  const bottomRightYCoord = top + height - Math.max(borderBottomWidth, rbr);\n\n  // Clip inner top left cap\n  ctx.bezierCurveTo(\n    left + width - borderRightWidth - c3,\n    top + height - borderBottomWidth,\n    left + width - borderRightWidth,\n    top + height - borderBottomWidth - c4,\n    left + width - borderRightWidth,\n    bottomRightYCoord,\n  );\n  ctx.lineTo(left + width, bottomRightYCoord);\n\n  // Move down in case the margin exceedes the radius\n  ctx.lineTo(left + width, top + height - rbr);\n\n  // Ellipse coefficients outer top left cap\n  const c5 = rbr * (1.0 - KAPPA);\n\n  // Clip outer top left cap\n  ctx.bezierCurveTo(\n    left + width,\n    top + height - c5,\n    left + width - c5,\n    top + height,\n    left + width - rbr,\n    top + height,\n  );\n  ctx.closePath();\n  ctx.clip();\n\n  // Clip border bottom cap joins\n  if (borderRightWidth) {\n    const brSlope = borderBottomWidth / borderRightWidth;\n    ctx.moveTo(left + width / 2, brSlope * (-width / 2) + top + height);\n    ctx.lineTo(left + width, top + height);\n    ctx.lineTo(left, top + height);\n    ctx.lineTo(left, top);\n    ctx.closePath();\n    ctx.clip();\n  }\n\n  if (borderLeftWidth) {\n    const trSlope = -borderBottomWidth / borderLeftWidth;\n    ctx.moveTo(left + width / 2, trSlope * (width / 2) + top + height);\n    ctx.lineTo(left, top + height);\n    ctx.lineTo(left + width, top + height);\n    ctx.lineTo(left + width, top);\n    ctx.closePath();\n    ctx.clip();\n  }\n};\n\nconst fillBorderBottom = (ctx, layout, style, rbl, rbr) => {\n  const { top, left, width, height } = layout;\n  const {\n    borderBottomColor,\n    borderBottomStyle,\n    borderBottomWidth,\n    borderRightWidth,\n    borderLeftWidth,\n  } = style;\n\n  const c0 = rbl * (1.0 - KAPPA);\n  const c1 = rbr * (1.0 - KAPPA);\n\n  ctx.moveTo(left + width, top + height - rbr);\n  ctx.bezierCurveTo(\n    left + width,\n    top + height - c1,\n    left + width - c1,\n    top + height,\n    left + width - rbr,\n    top + height,\n  );\n  ctx.lineTo(left + rbl, top + height);\n  ctx.bezierCurveTo(\n    left + c0,\n    top + height,\n    left,\n    top + height - c0,\n    left,\n    top + height - rbl,\n  );\n\n  ctx.strokeColor(borderBottomColor);\n  ctx.lineWidth(\n    Math.max(borderBottomWidth, borderRightWidth, borderLeftWidth) * 2,\n  );\n\n  if (borderBottomStyle === 'dashed') {\n    ctx.dash(borderBottomWidth * 2, { space: borderBottomWidth * 1.2 });\n  } else if (borderBottomStyle === 'dotted') {\n    ctx.dash(borderBottomWidth, { space: borderBottomWidth * 1.2 });\n  }\n\n  ctx.stroke();\n  ctx.undash();\n};\n\nconst clipBorderLeft = (ctx, layout, style, rbl, rtl) => {\n  const { top, left, width, height } = layout;\n  const { borderTopWidth, borderLeftWidth, borderBottomWidth } = style;\n\n  // Clip outer left border edge\n  ctx.moveTo(left, top + height - rbl);\n  ctx.lineTo(left, top + rtl);\n\n  // Ellipse coefficients outer top left cap\n  const c0 = rtl * (1.0 - KAPPA);\n\n  // Clip outer top left cap\n  ctx.bezierCurveTo(left, top + c0, left + c0, top, left + rtl, top);\n\n  // Move right in case the margin exceedes the radius\n  const topLeftCoordX = left + Math.max(borderLeftWidth, rtl);\n  ctx.lineTo(topLeftCoordX, top);\n\n  // Clip inner top left cap\n  ctx.lineTo(topLeftCoordX, top + borderTopWidth);\n\n  // Ellipse coefficients inner top left cap\n  const innerTopLeftRadiusX = Math.max(rtl - borderLeftWidth, 0);\n  const innerTopLeftRadiusY = Math.max(rtl - borderTopWidth, 0);\n  const c1 = innerTopLeftRadiusX * (1.0 - KAPPA);\n  const c2 = innerTopLeftRadiusY * (1.0 - KAPPA);\n\n  // Clip inner top right cap\n  ctx.bezierCurveTo(\n    left + borderLeftWidth + c1,\n    top + borderTopWidth,\n    left + borderLeftWidth,\n    top + borderTopWidth + c2,\n    left + borderLeftWidth,\n    top + Math.max(rtl, borderTopWidth),\n  );\n\n  // Clip inner left border edge\n  ctx.lineTo(\n    left + borderLeftWidth,\n    top + height - Math.max(rbl, borderBottomWidth),\n  );\n\n  // Ellipse coefficients inner bottom left cap\n  const innerBottomLeftRadiusX = Math.max(rbl - borderLeftWidth, 0);\n  const innerBottomLeftRadiusY = Math.max(rbl - borderBottomWidth, 0);\n  const c3 = innerBottomLeftRadiusX * (1.0 - KAPPA);\n  const c4 = innerBottomLeftRadiusY * (1.0 - KAPPA);\n  const bottomLeftXCoord = left + Math.max(rbl, borderLeftWidth);\n\n  // Clip inner top left cap\n  ctx.bezierCurveTo(\n    left + borderLeftWidth,\n    top + height - borderBottomWidth - c4,\n    left + borderLeftWidth + c3,\n    top + height - borderBottomWidth,\n    bottomLeftXCoord,\n    top + height - borderBottomWidth,\n  );\n  ctx.lineTo(bottomLeftXCoord, top + height);\n\n  // Move left in case the margin exceedes the radius\n  ctx.lineTo(left + rbl, top + height);\n\n  // Ellipse coefficients outer top right cap\n  const c5 = rbl * (1.0 - KAPPA);\n\n  // Clip outer top right cap\n  ctx.bezierCurveTo(\n    left + c5,\n    top + height,\n    left,\n    top + height - c5,\n    left,\n    top + height - rbl,\n  );\n\n  ctx.closePath();\n  ctx.clip();\n\n  // Clip border right cap joins\n  if (borderBottomWidth) {\n    const trSlope = -borderBottomWidth / borderLeftWidth;\n    ctx.moveTo(left + width / 2, trSlope * (width / 2) + top + height);\n    ctx.lineTo(left, top + height);\n    ctx.lineTo(left, top);\n    ctx.lineTo(left + width, top);\n    ctx.closePath();\n    ctx.clip();\n  }\n\n  if (borderBottomWidth) {\n    const trSlope = -borderTopWidth / borderLeftWidth;\n    ctx.moveTo(left + width / 2, trSlope * (-width / 2) + top);\n    ctx.lineTo(left, top);\n    ctx.lineTo(left, top + height);\n    ctx.lineTo(left + width, top + height);\n    ctx.closePath();\n    ctx.clip();\n  }\n};\n\nconst fillBorderLeft = (ctx, layout, style, rbl, rtl) => {\n  const { top, left, height } = layout;\n  const {\n    borderLeftColor,\n    borderLeftStyle,\n    borderLeftWidth,\n    borderTopWidth,\n    borderBottomWidth,\n  } = style;\n\n  const c0 = rbl * (1.0 - KAPPA);\n  const c1 = rtl * (1.0 - KAPPA);\n\n  ctx.moveTo(left + rbl, top + height);\n  ctx.bezierCurveTo(\n    left + c0,\n    top + height,\n    left,\n    top + height - c0,\n    left,\n    top + height - rbl,\n  );\n  ctx.lineTo(left, top + rtl);\n  ctx.bezierCurveTo(left, top + c1, left + c1, top, left + rtl, top);\n\n  ctx.strokeColor(borderLeftColor);\n  ctx.lineWidth(\n    Math.max(borderLeftWidth, borderTopWidth, borderBottomWidth) * 2,\n  );\n\n  if (borderLeftStyle === 'dashed') {\n    ctx.dash(borderLeftWidth * 2, { space: borderLeftWidth * 1.2 });\n  } else if (borderLeftStyle === 'dotted') {\n    ctx.dash(borderLeftWidth, { space: borderLeftWidth * 1.2 });\n  }\n\n  ctx.stroke();\n  ctx.undash();\n};\n\nconst shouldRenderBorders = node =>\n  node.box &&\n  (node.box.borderTopWidth ||\n    node.box.borderRightWidth ||\n    node.box.borderBottomWidth ||\n    node.box.borderLeftWidth);\n\nconst renderBorders = (ctx, node) => {\n  if (!shouldRenderBorders(node)) return node;\n\n  const {\n    width,\n    height,\n    borderTopWidth,\n    borderLeftWidth,\n    borderRightWidth,\n    borderBottomWidth,\n  } = node.box;\n\n  const {\n    opacity,\n    borderTopLeftRadius = 0,\n    borderTopRightRadius = 0,\n    borderBottomLeftRadius = 0,\n    borderBottomRightRadius = 0,\n    borderTopColor = 'black',\n    borderTopStyle = 'solid',\n    borderLeftColor = 'black',\n    borderLeftStyle = 'solid',\n    borderRightColor = 'black',\n    borderRightStyle = 'solid',\n    borderBottomColor = 'black',\n    borderBottomStyle = 'solid',\n  } = node.style;\n\n  const style = {\n    borderTopColor,\n    borderTopWidth,\n    borderTopStyle,\n    borderLeftColor,\n    borderLeftWidth,\n    borderLeftStyle,\n    borderRightColor,\n    borderRightWidth,\n    borderRightStyle,\n    borderBottomColor,\n    borderBottomWidth,\n    borderBottomStyle,\n    borderTopLeftRadius,\n    borderTopRightRadius,\n    borderBottomLeftRadius,\n    borderBottomRightRadius,\n  };\n\n  const rtr = Math.min(borderTopRightRadius, 0.5 * width, 0.5 * height);\n  const rtl = Math.min(borderTopLeftRadius, 0.5 * width, 0.5 * height);\n  const rbr = Math.min(borderBottomRightRadius, 0.5 * width, 0.5 * height);\n  const rbl = Math.min(borderBottomLeftRadius, 0.5 * width, 0.5 * height);\n\n  ctx.save();\n  ctx.strokeOpacity(opacity);\n\n  if (borderTopWidth) {\n    ctx.save();\n    clipBorderTop(ctx, node.box, style, rtr, rtl);\n    fillBorderTop(ctx, node.box, style, rtr, rtl);\n    ctx.restore();\n  }\n\n  if (borderRightWidth) {\n    ctx.save();\n    clipBorderRight(ctx, node.box, style, rtr, rbr);\n    fillBorderRight(ctx, node.box, style, rtr, rbr);\n    ctx.restore();\n  }\n\n  if (borderBottomWidth) {\n    ctx.save();\n    clipBorderBottom(ctx, node.box, style, rbl, rbr);\n    fillBorderBottom(ctx, node.box, style, rbl, rbr);\n    ctx.restore();\n  }\n\n  if (borderLeftWidth) {\n    ctx.save();\n    clipBorderLeft(ctx, node.box, style, rbl, rtl);\n    fillBorderLeft(ctx, node.box, style, rbl, rtl);\n    ctx.restore();\n  }\n\n  ctx.restore();\n\n  return node;\n};\n\nexport default R.curryN(2, renderBorders);\n","import * as R from 'ramda';\n\nimport save from './save';\nimport restore from './restore';\nimport clipNode from './clipNode';\n\nconst drawBackground = ctx => node => {\n  if (node.box && node.style.backgroundColor) {\n    const { top, left, width, height } = node.box;\n\n    ctx\n      .fillOpacity(node.style.opacity || 1)\n      .fillColor(node.style.backgroundColor)\n      .rect(left, top, width, height)\n      .fill();\n  }\n\n  return node;\n};\n\nconst shouldRenderBackground = R.hasPath(['style', 'backgroundColor']);\n\nconst renderBackground = (ctx, node) => {\n  R.when(\n    shouldRenderBackground,\n    R.compose(\n      restore(ctx),\n      drawBackground(ctx),\n      clipNode(ctx),\n      save(ctx),\n    ),\n  )(node);\n\n  return node;\n};\n\nexport default R.curryN(2, renderBackground);\n","import * as R from 'ramda';\n\n// TODO: Implement using only matrices to support skew and even more operations than css.\n\nconst getRotation = transform => {\n  const match = /rotate\\((-?\\d+.?\\d+)(.+)\\)/g.exec(transform);\n\n  if (match && match[1] && match[2]) {\n    const value = match[1];\n    return match[2] === 'rad' ? (value * 180) / Math.PI : value;\n  }\n\n  return 0;\n};\n\nconst getTranslateX = transform => {\n  const matchX = /translateX\\((-?\\d+\\.?d*)\\)/g.exec(transform);\n  const matchGeneric = /translate\\((-?\\d+\\.?d*).*,\\s*(-?\\d+\\.?d*).*\\)/g.exec(\n    transform,\n  );\n\n  if (matchX && matchX[1]) return matchX[1];\n  if (matchGeneric && matchGeneric[1]) return matchGeneric[1];\n\n  return 0;\n};\n\nconst getTranslateY = transform => {\n  const matchY = /translateY\\((-?\\d+\\.?\\d*)\\)/g.exec(transform);\n  const matchGeneric = /translate\\((-?\\d+\\.?\\d*).*,\\s*(-?\\d+\\.?\\d*).*\\)/g.exec(\n    transform,\n  );\n\n  if (matchY && matchY[1]) return matchY[1];\n  if (matchGeneric && matchGeneric[2]) return matchGeneric[2];\n\n  return 0;\n};\n\nconst getScaleX = transform => {\n  const matchX = /scaleX\\((-?\\d+\\.?\\d*)\\)/g.exec(transform);\n  const matchGeneric = /scale\\((-?\\d+\\.?\\d*).*,\\s*(-?\\d+\\.?\\d*).*\\)/g.exec(\n    transform,\n  );\n\n  if (matchX && matchX[1]) return matchX[1];\n  if (matchGeneric && matchGeneric[1]) return matchGeneric[1];\n\n  return 1;\n};\n\nconst getScaleY = transform => {\n  const matchY = /scaleY\\((-?\\d+\\.?\\d*)\\)/g.exec(transform);\n  const matchGeneric = /scale\\((-?\\d+\\.?\\d*).*,\\s*(-?\\d+\\.?\\d*).*\\)/g.exec(\n    transform,\n  );\n\n  if (matchY && matchY[1]) return matchY[1];\n  if (matchGeneric && matchGeneric[2]) return matchGeneric[2];\n\n  return 1;\n};\n\nconst getMatrix = transform => {\n  const match = /matrix\\(([^,]+),([^,]+),([^,]+),([^,]+),([^,]+),([^,]+)\\)/g.exec(\n    transform,\n  );\n  if (match) return match.slice(1, 7);\n  return null;\n};\n\nconst applySingleTransformation = (ctx, transform, origin) => {\n  if (/rotate/g.test(transform)) {\n    ctx.rotate(getRotation(transform), { origin });\n  } else if (/scaleX/g.test(transform)) {\n    ctx.scale(getScaleX(transform), 1, { origin });\n  } else if (/scaleY/g.test(transform)) {\n    ctx.scale(1, getScaleY(transform), { origin });\n  } else if (/scale/g.test(transform)) {\n    ctx.scale(getScaleX(transform), getScaleY(transform), {\n      origin,\n    });\n  } else if (/translateX/g.test(transform)) {\n    ctx.translate(getTranslateX(transform), 1, { origin });\n  } else if (/translateY/g.test(transform)) {\n    ctx.translate(1, getTranslateY(transform), { origin });\n  } else if (/translate/g.test(transform)) {\n    ctx.translate(getTranslateX(transform), getTranslateY(transform), {\n      origin,\n    });\n  } else if (/matrix/g.test(transform)) {\n    ctx.transform(...getMatrix(transform));\n  }\n};\n\nconst applyTransformations = (ctx, node) => {\n  if (!node.origin) return node;\n\n  let match;\n  const re = /[a-zA-Z]+\\([^)]+\\)/g;\n  const origin = [node.origin.left, node.origin.top];\n  const transform = (node.style && node.style.transform) || '';\n\n  while ((match = re.exec(transform)) != null) {\n    applySingleTransformation(ctx, match[0], origin);\n  }\n\n  return node;\n};\n\nexport default R.curryN(2, applyTransformations);\n","import * as R from 'ramda';\n\nimport Font from '../font';\nimport save from './save';\nimport restore from './restore';\nimport isText from '../node/isText';\nimport isPage from '../node/isPage';\nimport isImage from '../node/isImage';\nimport isNote from '../node/isNote';\nimport isLink from '../node/isLink';\nimport isCanvas from '../node/isCanvas';\nimport renderText from './renderText';\nimport renderPage from './renderPage';\nimport renderLink from './renderLink';\nimport renderNote from './renderNote';\nimport renderImage from './renderImage';\nimport renderCanvas from './renderCanvas';\nimport renderRulers from './renderRulers';\nimport addMetadata from './addMetadata';\nimport renderDebug from './renderDebug';\nimport renderBorders from './renderBorders';\nimport renderBackground from './renderBackground';\nimport applyTransformations from './applyTransformations';\n\nconst isNotText = R.complement(isText);\n\nconst renderNode = ctx => node => {\n  const renderChildren = R.tap(\n    R.compose(\n      R.forEach(renderNode(ctx)),\n      R.pathOr([], ['children']),\n    ),\n  );\n\n  return R.compose(\n    restore(ctx),\n    renderDebug(ctx),\n    R.when(isNotText, renderChildren),\n    R.cond([\n      [isText, renderText(ctx)],\n      [isLink, renderLink(ctx)],\n      [isNote, renderNote(ctx)],\n      [isImage, renderImage(ctx)],\n      [isCanvas, renderCanvas(ctx)],\n      [R.T, R.identity],\n    ]),\n    renderBorders(ctx),\n    renderBackground(ctx),\n    applyTransformations(ctx),\n    save(ctx),\n    R.when(isPage, renderPage(ctx)),\n  )(node);\n};\n\nconst renderDocument = ctx =>\n  R.compose(\n    R.forEach(\n      R.compose(\n        renderRulers(ctx),\n        renderNode(ctx),\n      ),\n    ),\n    R.pathOr([], ['children']),\n  );\n\nconst renderRoot = ctx =>\n  R.compose(\n    R.forEach(renderDocument(ctx)),\n    R.pathOr([], ['children']),\n  );\n\nconst render = (ctx, root) => {\n  addMetadata(ctx)(root);\n  renderRoot(ctx)(root);\n\n  ctx.end();\n  Font.reset();\n\n  return ctx;\n};\n\nexport default render;\n","import flatten from './flatten';\n\nconst create = styles => styles;\n\nconst absoluteFillObject = {\n  position: 'absolute',\n  top: 0,\n  left: 0,\n  bottom: 0,\n  right: 0,\n};\n\nexport default {\n  hairlineWidth: 1,\n  create,\n  flatten,\n  absoluteFillObject,\n};\n","import BlobStream from 'blob-stream';\nimport PDFDocument from '@react-pdf/pdfkit';\n\nimport createRenderer from './renderer';\nimport layoutDocument from './layout';\nimport renderPDF from './pdf/render';\nimport StyleSheet from './stylesheet';\nimport Font from './font';\nimport { version } from '../package.json';\nimport {\n  VIEW,\n  TEXT,\n  LINK,\n  PAGE,\n  NOTE,\n  IMAGE,\n  DOCUMENT,\n  CANVAS,\n} from './constants';\n\nconst View = VIEW;\nconst Text = TEXT;\nconst Link = LINK;\nconst Page = PAGE;\nconst Note = NOTE;\nconst Image = IMAGE;\nconst Document = DOCUMENT;\nconst Canvas = CANVAS;\n\nconst pdf = input => {\n  let _isDirty = true;\n\n  const container = { type: 'ROOT', children: [] };\n  const PDFRenderer = createRenderer(markAsDirty);\n  const mountNode = PDFRenderer.createContainer(container);\n\n  if (input) updateContainer(input);\n\n  function isDirty() {\n    return _isDirty;\n  }\n\n  function markAsDirty() {\n    _isDirty = true;\n  }\n\n  function callOnRender(params = {}) {\n    // if (container.document.props.onRender) {\n    // const layoutData = container.document.getLayoutData();\n    // container.document.props.onRender({ ...params, layoutData });\n    // }\n  }\n\n  const render = async () => {\n    const ctx = new PDFDocument({ autoFirstPage: false });\n\n    // let layout;\n\n    // for (let i = 0; i < 10; i++) {\n    console.time('layout');\n    const layout = await layoutDocument(container);\n    console.timeEnd('layout');\n    // }\n\n    const instance = renderPDF(ctx, layout);\n\n    _isDirty = false;\n\n    // console.log(layout);\n\n    return instance;\n  };\n\n  const renderWithContext = async ctx => {\n    const layout = await layoutDocument(container);\n    const instance = renderPDF(ctx, layout);\n    _isDirty = false;\n\n    return instance;\n  };\n\n  const layout = async () => {\n    return layoutDocument(container);\n  };\n\n  function updateContainer(doc) {\n    PDFRenderer.updateContainer(doc, mountNode, null);\n  }\n\n  async function toBlob() {\n    const instance = await render();\n    const stream = instance.pipe(BlobStream());\n\n    return new Promise((resolve, reject) => {\n      stream.on('finish', () => {\n        try {\n          const blob = stream.toBlob('application/pdf');\n          callOnRender({ blob });\n          resolve(blob);\n        } catch (error) {\n          reject(error);\n        }\n      });\n\n      stream.on('error', reject);\n    });\n  }\n\n  // async function toBuffer() {\n  //   await container.render();\n\n  //   callOnRender();\n\n  //   return container.instance;\n  // }\n\n  // function toString() {\n  //   let result = '';\n  //   container.render();\n\n  //   return new Promise((resolve, reject) => {\n  //     try {\n  //       container.instance.on('data', function(buffer) {\n  //         result += buffer;\n  //       });\n\n  //       container.instance.on('end', function() {\n  //         callOnRender({ string: result });\n  //         resolve(result);\n  //       });\n  //     } catch (error) {\n  //       reject(error);\n  //     }\n  //   });\n  // }\n\n  return {\n    layout,\n    isDirty,\n    container,\n    updateContainer,\n    renderWithContext,\n    // toBuffer,\n    toBlob,\n    toString,\n  };\n};\n\nexport {\n  version,\n  View,\n  Text,\n  Link,\n  Page,\n  Font,\n  Note,\n  Image,\n  Document,\n  Canvas,\n  StyleSheet,\n  pdf,\n};\n","import React from 'react';\n\nconst svgpath = require('svgpath');\n\nimport { pdf } from './index';\n\nconst queue = require('queue');\n\nconst canvasInstance = canvas => {\n  const instance = {};\n  const images = {};\n  const ctx = canvas.getContext('2d');\n\n  let fillColor = 'white';\n\n  const nil = () => {\n    return instance;\n  };\n\n  instance.info = {};\n  instance.end = nil;\n  instance.font = nil;\n\n  instance.translate = (x, y) => {\n    ctx.translate(x, y);\n    return instance;\n  };\n\n  instance.addPage = ({ size }) => {\n    canvas.width = size[0];\n    canvas.height = size[1];\n\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n  };\n\n  instance.save = () => {\n    ctx.save();\n    return instance;\n  };\n\n  instance.restore = () => {\n    ctx.restore();\n    return instance;\n  };\n\n  instance.moveTo = (x, y) => {\n    ctx.moveTo(x, y);\n    return instance;\n  };\n\n  instance.lineTo = (x, y) => {\n    ctx.lineTo(x, y);\n    return instance;\n  };\n\n  instance.bezierCurveTo = (a, b, c, d, e, f) => {\n    ctx.bezierCurveTo(a, b, c, d, e, f);\n    return instance;\n  };\n\n  instance.closePath = () => {\n    ctx.closePath();\n    return instance;\n  };\n\n  instance.clip = () => {\n    ctx.clip();\n    return instance;\n  };\n\n  instance.fillColor = color => {\n    fillColor = color;\n    return instance;\n  };\n\n  instance.rect = (a, b, c, d) => {\n    ctx.rect(a, b, c, d);\n    return instance;\n  };\n\n  instance.fill = () => {\n    ctx.fillStyle = fillColor;\n    ctx.fill();\n    return instance;\n  };\n\n  instance.fillOpacity = opacity => {\n    ctx.globalAlpha = opacity;\n    return instance;\n  };\n\n  instance._addGlyphs = (glyphs, positions) => {\n    let xAdvance = 0;\n    const fontSize = 20;\n    const unitsPerEm = 2048;\n\n    for (let i = 0; i < glyphs.length; i++) {\n      const glyph = glyphs[i];\n      const position = positions[i];\n\n      const path = svgpath(glyph.path.toSVG())\n        .scale(1, -1)\n        .scale(fontSize / unitsPerEm)\n        .translate(xAdvance, 0)\n        .toString();\n\n      xAdvance += position.xAdvance;\n\n      ctx.fillStyle = '#000';\n\n      const p = new Path2D(path);\n\n      ctx.stroke(p);\n      ctx.fill(p);\n    }\n\n    return instance;\n  };\n\n  instance.image = (data, x, y, { width, height }) => {\n    const base64Data = btoa(String.fromCharCode.apply(null, data));\n\n    if (images[base64Data]) {\n      ctx.drawImage(images[base64Data], x, y, width, height);\n    } else {\n      const img = document.createElement('img');\n      img.src = 'data:image/png;base64,' + base64Data;\n\n      images[base64Data] = img;\n\n      img.onload = () => {\n        ctx.drawImage(img, x, y, width, height);\n      };\n    }\n\n    return instance;\n  };\n\n  instance.clear = () => {\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n  };\n\n  return instance;\n};\n\nexport class CanvasViewer extends React.Component {\n  ctx = null;\n  instance = pdf();\n  renderQueue = queue({ autostart: true, concurrency: 1 });\n  state = { layout: null, error: null };\n\n  componentDidMount() {\n    this.ctx = canvasInstance(this.canvas);\n    this.queueDocumentRender(this.props.children);\n\n    this.renderQueue.on('error', this.onRenderFailed);\n    this.renderQueue.on('success', this.onRenderSuccessful);\n  }\n\n  componentDidUpdate(prevProps) {\n    if (prevProps.children !== this.props.children) {\n      this.queueDocumentRender(this.props.children);\n    }\n  }\n\n  queueDocumentRender(doc) {\n    this.renderQueue.splice(0, this.renderQueue.length, () => {\n      this.instance.updateContainer(doc);\n\n      if (this.instance.isDirty() && !this.state.error) {\n        return this.instance.renderWithContext(this.ctx);\n      }\n\n      return Promise.resolve();\n    });\n  }\n\n  onRenderFailed = error => {\n    this.setState({ error });\n    console.error(error);\n  };\n\n  onRenderSuccessful = layout => {\n    this.setState({ layout });\n  };\n\n  render() {\n    return (\n      <canvas\n        height={900}\n        id=\"myCanvas\"\n        ref={ref => (this.canvas = ref)}\n        style={{ border: '1px solid black' }}\n        width={900}\n      />\n    );\n  }\n}\n","/* eslint-disable no-unused-vars */\nimport React from 'react';\nimport { CanvasViewer } from './canvas';\n\nimport warning from '../src/utils/warning';\n\nconst queue = require('queue');\n\nimport {\n  pdf,\n  View,\n  Text,\n  Link,\n  Page,\n  Font,\n  Note,\n  Image,\n  Canvas,\n  version,\n  StyleSheet,\n  // createInstance,\n  Document as PDFDocument,\n} from './index';\n\nconst flatStyles = stylesArray =>\n  stylesArray.reduce((acc, style) => ({ ...acc, ...style }), {});\n\nexport const Document = ({ children, ...props }) => {\n  return <PDFDocument {...props}>{children}</PDFDocument>;\n};\n\nclass InternalBlobProvider extends React.PureComponent {\n  instance = pdf();\n  renderQueue = queue({ autostart: true, concurrency: 1 });\n  state = { blob: null, url: null, loading: true, error: null };\n\n  componentDidMount() {\n    this.queueDocumentRender(this.props.document);\n\n    this.renderQueue.on('error', this.onRenderFailed);\n    this.renderQueue.on('success', this.onRenderSuccessful);\n  }\n\n  componentDidUpdate(prevProps) {\n    if (prevProps.document !== this.props.document) {\n      this.queueDocumentRender(this.props.document);\n    }\n  }\n\n  queueDocumentRender(doc) {\n    this.renderQueue.splice(0, this.renderQueue.length, () => {\n      this.instance.updateContainer(doc);\n\n      if (this.instance.isDirty() && !this.state.error) {\n        return this.instance.toBlob();\n      }\n\n      return Promise.resolve();\n    });\n  }\n\n  onRenderFailed = error => {\n    this.setState({ error });\n    console.error(error);\n  };\n\n  onRenderSuccessful = blob => {\n    const oldBlobUrl = this.state.url;\n\n    this.setState(\n      { blob, url: URL.createObjectURL(blob), loading: false },\n      () => URL.revokeObjectURL(oldBlobUrl),\n    );\n  };\n\n  render() {\n    return this.props.children(this.state);\n  }\n}\n\nexport const BlobProvider = ({ document: doc, children }) => {\n  if (!doc) {\n    warning(false, 'You should pass a valid document to BlobProvider');\n    return null;\n  }\n\n  return <InternalBlobProvider document={doc}>{children}</InternalBlobProvider>;\n};\n\nexport const PDFViewer = ({\n  className,\n  style,\n  children,\n  innerRef,\n  ...props\n}) => {\n  return (\n    <InternalBlobProvider document={children}>\n      {({ url }) => (\n        <iframe\n          className={className}\n          ref={innerRef}\n          src={url}\n          style={Array.isArray(style) ? flatStyles(style) : style}\n          {...props}\n        />\n      )}\n    </InternalBlobProvider>\n  );\n};\n\nexport const PDFDownloadLink = ({\n  document: doc,\n  className,\n  style,\n  children,\n  fileName = 'document.pdf',\n}) => {\n  if (!doc) {\n    warning(false, 'You should pass a valid document to PDFDownloadLink');\n    return null;\n  }\n\n  const downloadOnIE = blob => () => {\n    if (window.navigator.msSaveBlob) {\n      window.navigator.msSaveBlob(blob, fileName);\n    }\n  };\n\n  return (\n    <InternalBlobProvider document={doc}>\n      {params => (\n        <a\n          className={className}\n          download={fileName}\n          href={params.url}\n          onClick={downloadOnIE(params.blob)}\n          style={Array.isArray(style) ? flatStyles(style) : style}\n        >\n          {typeof children === 'function' ? children(params) : children}\n        </a>\n      )}\n    </InternalBlobProvider>\n  );\n};\n\nexport {\n  pdf,\n  View,\n  Text,\n  Link,\n  Page,\n  Font,\n  Note,\n  Image,\n  Canvas,\n  version,\n  StyleSheet,\n} from './index';\n\nexport { CanvasViewer } from './canvas';\n\nexport default {\n  pdf,\n  View,\n  Text,\n  Link,\n  Page,\n  Font,\n  Note,\n  Image,\n  Canvas,\n  version,\n  Document,\n  PDFViewer,\n  StyleSheet,\n  CanvasViewer,\n  BlobProvider,\n  PDFDownloadLink,\n};\n"],"names":["emojiSource","hyphenationCallback","propsEqual","a","b","oldPropsKeys","Object","keys","newPropsKeys","length","i","propName","emptyObject","createRenderer","onChange","ReactFiberReconciler","supportsMutation","appendInitialChild","parentInstance","child","children","push","createInstance","type","style","box","props","createTextInstance","text","rootContainerInstance","value","finalizeInitialChildren","element","getPublicInstance","instance","prepareForCommit","prepareUpdate","oldProps","newProps","resetAfterCommit","c","resetTextContent","getRootHostContext","getChildHostContext","shouldSetTextContent","now","Date","useSyncScheduling","appendChild","appendChildToContainer","insertBefore","beforeChild","index","indexOf","splice","removeChild","removeChildFromContainer","commitTextUpdate","textInstance","oldText","newText","commitUpdate","updatePayload","VIEW","TEXT","LINK","PAGE","NOTE","IMAGE","DOCUMENT","CANVAS","TEXT_INSTANCE","DPI","FONT_WEIGHTS","thin","hairline","ultralight","extralight","light","normal","medium","semibold","demibold","bold","ultrabold","extrabold","heavy","black","PAGE_SIZES","A0","A1","A2","A3","A4","A5","A6","A7","A8","A9","A10","B0","B1","B2","B3","B4","B5","B6","B7","B8","B9","B10","C0","C1","C2","C3","C4","C5","C6","C7","C8","C9","C10","RA0","RA1","RA2","RA3","RA4","SRA0","SRA1","SRA2","SRA3","SRA4","EXECUTIVE","FOLIO","LEGAL","LETTER","TABLOID","PORTRAIT","LANDSCAPE","INHERITED_PROPERTIES","RULER_WIDTH","RULER_COLOR","RULER_FONT_SIZE","DEFAULT_RULER_STEPS","LINE_WIDTH","LINE_COLOR","GRID_COLOR","BOX_MODEL_REGEX","OBJECT_POSITION_REGEX","BORDER_SHORTHAND_REGEX","TRANSFORM_ORIGIN_REGEX","matchBoxModel","R","matchObjectPosition","matchBorderShorthand","matchTransformOrigin","isFontWeightStyle","key","match","isBorderStyle","isBoxModelStyle","isObjectPositionStyle","isTransformOriginStyle","processBorders","Error","processBoxModel","processFontWeight","toLowerCase","processObjectPosition","transformOffsetKeywords","processTransformOrigin","result","matchNumber","String","castFloat","v","parseFloat","transformStyles","propsArray","resolvedStyle","fetchFont","src","options","fetch","response","buffer","arrayBuffer","constructor","name","Buffer","from","FontSource","fontFamily","fontStyle","fontWeight","data","loading","load","this","headers","body","method","fontkit","create","Promise","resolve","reject","open","_this","err","Font","family","sources","register","descriptor","res","styleSources","filter","s","exactFit","find","leftOffset","rightOffset","lt","gt","registerEmojiSource","url","format","getEmojiSource","registerHyphenationCallback","callback","getHyphenationCallback","printWarning","args","argIndex","message","replace","console","error","x","__DEV__","process","env","NODE_ENV","warning","condition","undefined","fonts","font","getRegisteredFonts","getRegisteredFontFamilies","getFont","standardFonts","includes","reset","hasOwnProperty","clear","emoji","hyphenation","isImage","PNG","isValid","e","MARKERS","JPEG","width","height","readUInt16BE","marker","pos","isBuffer","createCache","limit","cache","get","set","shift","IMAGE_CACHE","getAbsoluteLocalPath","fetchLocalFile","fetchRemoteFile","uri","isValidFormat","lower","guessFormat","isCompatibleBase64","test","getImage","extension","resolveBase64Image","exec","resolveImageFromData","JSON","stringify","resolveBufferImage","getImageFormat","isPng","isJpg","resolveImageFromUrl","resolveImage","image","cacheKey","toString","getSource","fetchImage","node","warn","_context","emojis","regex","emojiRegex","reflect","promise","then","makeFetchEmojiImage","_removeNoColor","getCodePoints","string","Array","map","char","codePointAt","join","buildEmojiUrl","fetchEmojis","promises","emojiUrl","fetchEmojiImage","embedEmojis","fragments","fragment","lastIndex","emojiSize","attributes","fontSize","chunk","slice","fromCharCode","attachment","yOffset","Math","floor","fetchAssets","listToExplore","forEach","childNode","resolveAssets","p","all","compact","Boolean","isArray","isNotArray","castArray","mergeStyles","styles","reduce","acc","flatten","prototype","styleShorthands","margin","marginTop","marginRight","marginBottom","marginLeft","marginHorizontal","marginVertical","padding","paddingTop","paddingRight","paddingBottom","paddingLeft","paddingHorizontal","paddingVertical","border","borderTopColor","borderTopStyle","borderTopWidth","borderRightColor","borderRightStyle","borderRightWidth","borderBottomColor","borderBottomStyle","borderBottomWidth","borderLeftColor","borderLeftStyle","borderLeftWidth","borderTop","borderRight","borderBottom","borderLeft","borderColor","borderRadius","borderTopLeftRadius","borderTopRightRadius","borderBottomRightRadius","borderBottomLeftRadius","borderStyle","borderWidth","objectPosition","objectPositionX","objectPositionY","transformOrigin","transformOriginX","transformOriginY","expandedKeys","expandStyles","expandedProps","call","parseValue","unit","transformUnit","container","scalar","transformUnits","resolveMediaQueries","matchMedia","resolveStyles","flattenStyles","resolveNodeStyles","page","resolvePageStyles","pageBox","resolveZIndex","hasVerticalRuler","hasHorizontalRuler","adjustPageSize","top","left","resolveRulers","isPercent","matchPercent","percent","absValue","abs","absPercent","getTransformStyle","getOrigin","percentX","percentY","resolveNodeOrigin","resolveOrigin","VALID_ORIENTATIONS","getOrientation","isLandscape","toSizeObject","flipSizeObject","getStringSize","getNumberSize","throwInvalidError","size","getSize","Number","assocIfNil","target","resolvePageSize","getPageSize","resolvePageSizes","isNotNil","firstPass","fns","fn","getComputedMargin","edge","yogaNode","_yogaNode","getMargin","Yoga","EDGE_TOP","EDGE_RIGHT","EDGE_BOTTOM","EDGE_LEFT","getComputedPadding","getPadding","getTop","getComputedTop","getRight","getComputedRight","getBottom","getComputedBottom","getLeft","getComputedLeft","getPosition","right","bottom","DEFAULT_DIMENSION","getDimension","getComputedWidth","getComputedHeight","getComputedBorder","getBorderWidth","upperFirst","setYogaValue","attr","hasEdge","fixedMethod","autoMethod","percentMethod","setFlex","setDisplay","DISPLAY_NONE","DISPLAY_FLEX","setOverflow","yogaValue","OVERFLOW_HIDDEN","OVERFLOW_SCROLL","OVERFLOW_VISIBLE","setFlexWrap","WRAP_WRAP","WRAP_WRAP_REVERSE","WRAP_NO_WRAP","setFlexGrow","setFlexBasis","setAlign","ALIGN_FLEX_START","ALIGN_CENTER","ALIGN_FLEX_END","ALIGN_STRETCH","ALIGN_BASELINE","ALIGN_SPACE_BETWEEN","ALIGN_SPACE_AROUND","ALIGN_AUTO","setAlignSelf","setFlexShrink","setAspectRatio","setAlignContent","setPositionType","POSITION_TYPE_ABSOLUTE","POSITION_TYPE_RELATIVE","isRow","isRowReverse","isColumnReverse","setFlexDirection","FLEX_DIRECTION_ROW","FLEX_DIRECTION_ROW_REVERSE","FLEX_DIRECTION_COLUMN_REVERSE","FLEX_DIRECTION_COLUMN","setJustifyContent","JUSTIFY_CENTER","JUSTIFY_FLEX_END","JUSTIFY_SPACE_BETWEEN","JUSTIFY_SPACE_AROUND","JUSTIFY_SPACE_EVENLY","JUSTIFY_FLEX_START","setMarginTop","setMarginRight","setMarginBottom","setMarginLeft","setMargin","setPaddingTop","setPaddingRight","setPaddingBottom","setPaddingLeft","setBorderTop","setBorderRight","setBorderBottom","setBorderLeft","setPositionTop","setPositionRight","setPositionBottom","setPositionLeft","setWidth","setMinWidth","setMaxWidth","setHeight","setMinHeight","setMaxHeight","isText","isNote","isPage","isCanvas","StandardFont","PDFFont","layout","str","encode","encoded","positions","stringIndices","_","glyphs","g","glyph","getGlyph","parseInt","advanceWidth","glyphForCodePoint","codePoint","id","_font","codePoints","isLigature","characterToGlyph","hasGlyphForCodePoint","fontCache","IGNORED_CODE_POINTS","getFontSize","getOrCreateFont","getFallbackFont","shouldFallbackToFont","fontSubstitution","runs","lastFont","run","defaultFont","start","end","scale","unitsPerEm","capitalize","l","toUpperCase","IGNORABLE_CODEPOINTS","buildSubsetForFont","ignoreChars","charSubset","subsetRegex","RegExp","isTextInstance","PREPROCESSORS","transformText","transformation","getFragments","color","backgroundColor","textAlign","lineHeight","textDecoration","textDecorationColor","textDecorationStyle","textTransform","letterSpacing","textIndent","opacity","obj","align","indent","link","characterSpacing","underlineStyle","underline","underlineColor","strike","strikeStyle","strikeColor","preprocessor","getAttributedString","AttributedString","fromFragments","engines","linebreaker","justification","scriptItemizer","wordHyphenation","engine","layoutEngine","getContainer","y","maxLines","Infinity","truncateMode","getLayoutOptions","hyphenationPenalty","shrinkWhitespaceFactor","before","after","layoutText","linesWidth","lines","max","line","linesHeight","measureText","widthMode","heightMode","MEASURE_MODE_EXACTLY","MEASURE_MODE_AT_MOST","min","getRatio","isHeightAuto","SAFETY_HEIGHT","measureImage","imageRatio","imageMargin","pagePadding","pageArea","MEASURE_MODE_UNDEFINED","scaledHeight","getMax","measureCtx","ctx","points","nil","addPoint","moveTo","rect","w","h","ellipse","rx","ry","lineTo","circle","polygon","roundedRect","path","lineWidth","bezierCurveTo","quadraticCurveTo","rotate","translate","dash","clip","save","fill","stroke","lineCap","restore","lineJoin","fillColor","miterLimit","strokeColor","fillOpacity","strokeOpacity","linearGradient","radialGradient","getWidth","getHeight","measureCanvas","paint","YOGA_NODE","YOGA_CONFIG","Config","setPointScaleFactor","setNodeHeight","setYogaValues","minWidth","maxWidth","minHeight","maxHeight","position","display","flexDirection","alignSelf","alignContent","justifyContent","flexWrap","overflow","aspectRatio","flex","flexBasis","flexGrow","flexShrink","insertYogaNodes","parent","insertChild","getChildCount","setMeasureFunc","isNotText","isNotNote","isLayoutElement","isNotTextInstance","createYogaNodes","Node","createWithConfig","calculateLayout","persistDimensions","destroyYogaNodes","n","destroy","resolvePageDimensions","resolveDimensions","shouldLayoutText","resolveTextLayout","getInheritStyles","resolveInheritance","inheritStyles","removeMargins","resolvePageMargins","getNodesHeight","nodes","getWrap","getBreak","getMinPresenceAhead","defaultPresenceAhead","getPresenceAhead","elements","isElementInside","presenceAhead","shouldBreak","futureElements","minPresenceAhead","futureHeight","shouldSplit","shouldWrap","getPaddingBottom","getContentArea","getChildren","setChildren","setBreak","breakChildren","offset","nextElements","currentElements","childTop","childHeight","shouldNodeBreak","currentChildren","nextChildren","childsOffset","ceil","breakNode","breakPage","pages","subpages","current","nextPage","resolvePageBreaks","isElementOutside","splitNodes","splitNode","currentChild","nextChild","splitChildren","availableHeight","nodeTop","currentChilds","getWrappingArea","splitPage","splittedPage","resolvePageSplitting","restorePageSize","resolvePageWrapping","getNodeText","getNodesText","wrapTextInstance","resolveNoteChildren","resolvePageHorizontalPadding","resolvePageVerticalPadding","resolvePagePaddings","resolveRadius","resolvePercentRadius","transformHeight","getPageArea","hasHeight","resolveNodePercentHeight","resolvePagePercentHeight","resolvePercentHeight","isLink","hasRenderProp","hasTextInstanceChilds","resolveLinkSubstitution","resolveAbsoluteCoordinates","origin","asyncCompose","startTimer","time","endTimer","timeEnd","resolvePageSizeStyle","resolveOrigins","renderText","initialY","PDFRenderer","render","renderPage","addPage","PROTOCOL_REGEXP","getURL","renderLink","renderNote","note","KAPPA","sqrt","clipNode","rtr","ctr","rbr","cbr","rbl","cbl","rtl","ctl","closePath","isNumeric","isNaN","isFinite","applyContainObjectFit","cw","ch","iw","ih","px","py","cr","ir","pxp","pyp","pxv","pyv","xOffset","applyNoneObjectFit","applyCoverObjectFit","applyScaleDownObjectFit","containDimension","noneDimension","applyFillObjectFit","resolveObjectFit","drawImage","objectFit","renderImage","availableMethods","painter","prop","defaultsZero","renderCanvas","availableWidth","range","steps","matchPercentage","getVerticalSteps","horizontalRulerSteps","rulerSteps","percentage","getHorizontalSteps","verticalRulerSteps","renderVerticalRuler","hRange","step","round","renderHorizontalRuler","renderRulers","getDocumentProp","or","setPDFMetadata","info","addMetadata","root","getProp","setProp","title","author","subject","keywords","creator","producer","CONTENT_COLOR","PADDING_COLOR","MARGIN_COLOR","shouldDebug","debugContent","debugPadding","debugMargin","debugText","roundedWidth","roundedHeight","debugOrigin","renderDebug","clipBorderTop","c0","topRightYCoord","innerTopRightRadiusX","innerTopRightRadiusY","c1","c2","innerTopLeftRadiusX","innerTopLeftRadiusY","c3","c4","topLeftYCoord","c5","trSlope","fillBorderTop","space","undash","clipBorderRight","topBottomXCoord","innerBottomRightRadiusX","innerBottomRightRadiusY","topRightXCoord","brSlope","fillBorderRight","clipBorderBottom","bottomLeftYCoord","innerBottomLeftRadiusX","innerBottomLeftRadiusY","bottomRightYCoord","fillBorderBottom","clipBorderLeft","topLeftCoordX","bottomLeftXCoord","fillBorderLeft","shouldRenderBorders","renderBorders","drawBackground","shouldRenderBackground","renderBackground","getRotation","transform","PI","getTranslateX","matchX","matchGeneric","getTranslateY","matchY","getScaleX","getScaleY","getMatrix","applySingleTransformation","applyTransformations","re","renderNode","renderChildren","renderDocument","renderRoot","absoluteFillObject","hairlineWidth","View","Text","Link","Page","Note","Image","Document","Canvas","pdf","input","_isDirty","mountNode","createContainer","updateContainer","PDFDocument","autoFirstPage","layoutDocument","renderPDF","renderWithContext","doc","stream","pipe","BlobStream","on","blob","toBlob","isDirty","svgpath","require","queue","canvasInstance","canvas","images","getContext","clearRect","d","f","fillStyle","globalAlpha","_addGlyphs","xAdvance","toSVG","Path2D","base64Data","btoa","apply","img","document","createElement","onload","CanvasViewer","renderQueue","autostart","concurrency","state","onRenderFailed","setState","onRenderSuccessful","componentDidMount","queueDocumentRender","componentDidUpdate","prevProps","_this2","React","ref","_this3","Component","flatStyles","stylesArray","InternalBlobProvider","oldBlobUrl","URL","createObjectURL","revokeObjectURL","PureComponent","BlobProvider","PDFViewer","className","innerRef","PDFDownloadLink","fileName","params","download","href","onClick","window","navigator","msSaveBlob","version","StyleSheet"],"mappings":"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"}